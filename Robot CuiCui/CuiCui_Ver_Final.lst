CCS PCH C Compiler, Version 5.081d, 1               18-nov.-18 19:08
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   C:\Users\Jose\Desktop\Robot CuiCui\CuiCui_Ver_Final.lst

               ROM used:   8462 bytes (26%)
                           Largest free fragment is 24302
               RAM used:   240 (16%) at main() level
                           295 (19%) worst case
               Stack used: 5 locations (3 in main + 2 for interrupts)
               Stack size: 31

*
0000:  GOTO   19C0
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FA0.1
0056:  GOTO   0060
005A:  BTFSC  FA1.1
005C:  GOTO   0690
0060:  BTFSS  FF2.4
0062:  GOTO   006C
0066:  BTFSC  FF2.1
0068:  GOTO   0CDC
006C:  BTFSS  F9D.5
006E:  GOTO   0078
0072:  BTFSC  F9E.5
0074:  GOTO   0C8C
0078:  BTFSS  FA0.6
007A:  GOTO   0084
007E:  BTFSC  FA1.6
0080:  GOTO   0CA4
0084:  MOVFF  0E,00
0088:  MOVFF  0F,01
008C:  MOVFF  10,02
0090:  MOVFF  11,03
0094:  MOVFF  0C,FE9
0098:  MOVFF  07,FEA
009C:  BSF    07.7
009E:  MOVFF  08,FE1
00A2:  MOVFF  09,FE2
00A6:  MOVFF  0A,FD9
00AA:  MOVFF  0B,FDA
00AE:  MOVFF  12,FF3
00B2:  MOVFF  13,FF4
00B6:  MOVFF  14,FFA
00BA:  MOVFF  15,FF5
00BE:  MOVFF  16,FF6
00C2:  MOVFF  17,FF7
00C6:  MOVF   04,W
00C8:  MOVFF  06,FE0
00CC:  MOVFF  05,FD8
00D0:  RETFIE 0
....................     
.................... #include "C:\Users\Jose\Desktop\Robot CuiCui\CuiCui_Ver_Final.h" 
.................... #include <18F2520.h> 
.................... //////////// Standard Header file for the PIC18F2520 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F2520 
00D2:  DATA 31,2E
00D4:  DATA 30,00
00D6:  DATA 00,00
00D8:  MOVLW  8E
00DA:  MOVWF  00
00DC:  MOVFF  118,01
00E0:  MOVFF  117,02
00E4:  CLRF   03
00E6:  MOVF   01,F
00E8:  BNZ   00FC
00EA:  MOVFF  02,01
00EE:  CLRF   02
00F0:  MOVLW  08
00F2:  SUBWF  00,F
00F4:  MOVF   01,F
00F6:  BNZ   00FC
00F8:  CLRF   00
00FA:  BRA    010C
00FC:  BCF    FD8.0
00FE:  BTFSC  01.7
0100:  BRA    010A
0102:  RLCF   02,F
0104:  RLCF   01,F
0106:  DECF   00,F
0108:  BRA    00FC
010A:  BCF    01.7
010C:  RETURN 0
010E:  MOVLW  80
0110:  BTFSS  FD8.1
0112:  BRA    0118
0114:  MOVLB  1
0116:  XORWF  x1C,F
0118:  MOVLB  1
011A:  CLRF   x21
011C:  CLRF   x22
011E:  MOVFF  118,120
0122:  MOVF   x1C,W
0124:  XORWF  x20,F
0126:  MOVF   x17,W
0128:  BTFSC  FD8.2
012A:  BRA    02EA
012C:  MOVWF  x1F
012E:  MOVWF  00
0130:  MOVF   x1B,W
0132:  BTFSC  FD8.2
0134:  BRA    02FC
0136:  SUBWF  x1F,F
0138:  BTFSC  FD8.2
013A:  BRA    0242
013C:  BNC   01BA
013E:  MOVFF  11C,125
0142:  BSF    x25.7
0144:  MOVFF  11D,124
0148:  MOVFF  11E,123
014C:  CLRF   x22
014E:  BCF    FD8.0
0150:  RRCF   x25,F
0152:  RRCF   x24,F
0154:  RRCF   x23,F
0156:  RRCF   x22,F
0158:  DECFSZ x1F,F
015A:  BRA    014C
015C:  BTFSS  x20.7
015E:  BRA    0166
0160:  BSF    x21.0
0162:  BRA    0324
0164:  BCF    x21.0
0166:  BCF    x1F.0
0168:  BSF    x21.4
016A:  MOVLW  01
016C:  MOVWF  FEA
016E:  MOVLW  1A
0170:  MOVWF  FE9
0172:  BRA    034A
0174:  BCF    x21.4
0176:  BTFSC  x20.7
0178:  BRA    018E
017A:  BTFSS  x1F.0
017C:  BRA    01A4
017E:  RRCF   x25,F
0180:  RRCF   x24,F
0182:  RRCF   x23,F
0184:  RRCF   x22,F
0186:  INCF   00,F
0188:  BTFSC  FD8.2
018A:  BRA    031A
018C:  BRA    01A4
018E:  BTFSC  x25.7
0190:  BRA    01AA
0192:  BCF    FD8.0
0194:  RLCF   x22,F
0196:  RLCF   x23,F
0198:  RLCF   x24,F
019A:  RLCF   x25,F
019C:  DECF   00,F
019E:  BTFSC  FD8.2
01A0:  BRA    031A
01A2:  BRA    018E
01A4:  BSF    x21.6
01A6:  BRA    0282
01A8:  BCF    x21.6
01AA:  MOVFF  118,120
01AE:  BTFSS  x18.7
01B0:  BRA    01B6
01B2:  BSF    x25.7
01B4:  BRA    030C
01B6:  BCF    x25.7
01B8:  BRA    030C
01BA:  MOVFF  11B,11F
01BE:  MOVFF  11B,00
01C2:  MOVF   x17,W
01C4:  SUBWF  x1F,F
01C6:  MOVFF  118,125
01CA:  BSF    x25.7
01CC:  MOVFF  119,124
01D0:  MOVFF  11A,123
01D4:  CLRF   x22
01D6:  BCF    FD8.0
01D8:  RRCF   x25,F
01DA:  RRCF   x24,F
01DC:  RRCF   x23,F
01DE:  RRCF   x22,F
01E0:  DECFSZ x1F,F
01E2:  BRA    01D4
01E4:  BTFSS  x20.7
01E6:  BRA    01EE
01E8:  BSF    x21.1
01EA:  BRA    0324
01EC:  BCF    x21.1
01EE:  BCF    x1F.0
01F0:  BSF    x21.5
01F2:  MOVLW  01
01F4:  MOVWF  FEA
01F6:  MOVLW  1E
01F8:  MOVWF  FE9
01FA:  BRA    034A
01FC:  BCF    x21.5
01FE:  BTFSC  x20.7
0200:  BRA    0216
0202:  BTFSS  x1F.0
0204:  BRA    022C
0206:  RRCF   x25,F
0208:  RRCF   x24,F
020A:  RRCF   x23,F
020C:  RRCF   x22,F
020E:  INCF   00,F
0210:  BTFSC  FD8.2
0212:  BRA    031A
0214:  BRA    022C
0216:  BTFSC  x25.7
0218:  BRA    0232
021A:  BCF    FD8.0
021C:  RLCF   x22,F
021E:  RLCF   x23,F
0220:  RLCF   x24,F
0222:  RLCF   x25,F
0224:  DECF   00,F
0226:  BTFSC  FD8.2
0228:  BRA    031A
022A:  BRA    0216
022C:  BSF    x21.7
022E:  BRA    0282
0230:  BCF    x21.7
0232:  MOVFF  11C,120
0236:  BTFSS  x1C.7
0238:  BRA    023E
023A:  BSF    x25.7
023C:  BRA    030C
023E:  BCF    x25.7
0240:  BRA    030C
0242:  MOVFF  11C,125
0246:  BSF    x25.7
0248:  MOVFF  11D,124
024C:  MOVFF  11E,123
0250:  BTFSS  x20.7
0252:  BRA    025C
0254:  BCF    x25.7
0256:  BSF    x21.2
0258:  BRA    0324
025A:  BCF    x21.2
025C:  CLRF   x22
025E:  BCF    x1F.0
0260:  MOVLW  01
0262:  MOVWF  FEA
0264:  MOVLW  1A
0266:  MOVWF  FE9
0268:  BRA    034A
026A:  BTFSC  x20.7
026C:  BRA    02A6
026E:  MOVFF  118,120
0272:  BTFSS  x1F.0
0274:  BRA    0282
0276:  RRCF   x25,F
0278:  RRCF   x24,F
027A:  RRCF   x23,F
027C:  RRCF   x22,F
027E:  INCF   00,F
0280:  BZ    031A
0282:  BTFSS  x22.7
0284:  BRA    029C
0286:  INCF   x23,F
0288:  BNZ   029C
028A:  INCF   x24,F
028C:  BNZ   029C
028E:  INCF   x25,F
0290:  BNZ   029C
0292:  RRCF   x25,F
0294:  RRCF   x24,F
0296:  RRCF   x23,F
0298:  INCF   00,F
029A:  BZ    031A
029C:  BTFSC  x21.6
029E:  BRA    01A8
02A0:  BTFSC  x21.7
02A2:  BRA    0230
02A4:  BRA    02DE
02A6:  MOVLW  80
02A8:  XORWF  x25,F
02AA:  BTFSS  x25.7
02AC:  BRA    02B6
02AE:  BRA    0324
02B0:  MOVFF  11C,120
02B4:  BRA    02CA
02B6:  MOVFF  118,120
02BA:  MOVF   x25,F
02BC:  BNZ   02CA
02BE:  MOVF   x24,F
02C0:  BNZ   02CA
02C2:  MOVF   x23,F
02C4:  BNZ   02CA
02C6:  CLRF   00
02C8:  BRA    030C
02CA:  BTFSC  x25.7
02CC:  BRA    02DE
02CE:  BCF    FD8.0
02D0:  RLCF   x22,F
02D2:  RLCF   x23,F
02D4:  RLCF   x24,F
02D6:  RLCF   x25,F
02D8:  DECFSZ 00,F
02DA:  BRA    02CA
02DC:  BRA    031A
02DE:  BTFSS  x20.7
02E0:  BRA    02E6
02E2:  BSF    x25.7
02E4:  BRA    030C
02E6:  BCF    x25.7
02E8:  BRA    030C
02EA:  MOVFF  11B,00
02EE:  MOVFF  11C,125
02F2:  MOVFF  11D,124
02F6:  MOVFF  11E,123
02FA:  BRA    030C
02FC:  MOVFF  117,00
0300:  MOVFF  118,125
0304:  MOVFF  119,124
0308:  MOVFF  11A,123
030C:  MOVFF  125,01
0310:  MOVFF  124,02
0314:  MOVFF  123,03
0318:  BRA    0382
031A:  CLRF   00
031C:  CLRF   01
031E:  CLRF   02
0320:  CLRF   03
0322:  BRA    0382
0324:  CLRF   x22
0326:  COMF   x23,F
0328:  COMF   x24,F
032A:  COMF   x25,F
032C:  COMF   x22,F
032E:  INCF   x22,F
0330:  BNZ   033C
0332:  INCF   x23,F
0334:  BNZ   033C
0336:  INCF   x24,F
0338:  BNZ   033C
033A:  INCF   x25,F
033C:  BTFSC  x21.0
033E:  BRA    0164
0340:  BTFSC  x21.1
0342:  BRA    01EC
0344:  BTFSC  x21.2
0346:  BRA    025A
0348:  BRA    02B0
034A:  MOVF   FEF,W
034C:  ADDWF  x23,F
034E:  BNC   035A
0350:  INCF   x24,F
0352:  BNZ   035A
0354:  INCF   x25,F
0356:  BTFSC  FD8.2
0358:  BSF    x1F.0
035A:  MOVF   FED,F
035C:  MOVF   FEF,W
035E:  ADDWF  x24,F
0360:  BNC   0368
0362:  INCF   x25,F
0364:  BTFSC  FD8.2
0366:  BSF    x1F.0
0368:  MOVF   FED,F
036A:  MOVF   FEF,W
036C:  BTFSC  FEF.7
036E:  BRA    0372
0370:  XORLW  80
0372:  ADDWF  x25,F
0374:  BTFSC  FD8.0
0376:  BSF    x1F.0
0378:  BTFSC  x21.4
037A:  BRA    0174
037C:  BTFSC  x21.5
037E:  BRA    01FC
0380:  BRA    026A
0382:  MOVLB  0
0384:  RETURN 0
0386:  MOVLB  1
0388:  MOVF   x17,W
038A:  BTFSC  FD8.2
038C:  BRA    04D8
038E:  MOVWF  x23
0390:  MOVF   x1B,W
0392:  BTFSC  FD8.2
0394:  BRA    04D8
0396:  SUBWF  x23,F
0398:  BNC   03A4
039A:  MOVLW  7F
039C:  ADDWF  x23,F
039E:  BTFSC  FD8.0
03A0:  BRA    04D8
03A2:  BRA    03B0
03A4:  MOVLW  81
03A6:  SUBWF  x23,F
03A8:  BTFSS  FD8.0
03AA:  BRA    04D8
03AC:  BTFSC  FD8.2
03AE:  BRA    04D8
03B0:  MOVFF  123,00
03B4:  CLRF   01
03B6:  CLRF   02
03B8:  CLRF   03
03BA:  CLRF   x22
03BC:  MOVFF  118,121
03C0:  BSF    x21.7
03C2:  MOVFF  119,120
03C6:  MOVFF  11A,11F
03CA:  MOVLW  19
03CC:  MOVWF  x23
03CE:  MOVF   x1E,W
03D0:  SUBWF  x1F,F
03D2:  BC    03EE
03D4:  MOVLW  01
03D6:  SUBWF  x20,F
03D8:  BC    03EE
03DA:  SUBWF  x21,F
03DC:  BC    03EE
03DE:  SUBWF  x22,F
03E0:  BC    03EE
03E2:  INCF   x22,F
03E4:  INCF   x21,F
03E6:  INCF   x20,F
03E8:  MOVF   x1E,W
03EA:  ADDWF  x1F,F
03EC:  BRA    043E
03EE:  MOVF   x1D,W
03F0:  SUBWF  x20,F
03F2:  BC    0418
03F4:  MOVLW  01
03F6:  SUBWF  x21,F
03F8:  BC    0418
03FA:  SUBWF  x22,F
03FC:  BC    0418
03FE:  INCF   x22,F
0400:  INCF   x21,F
0402:  MOVF   x1D,W
0404:  ADDWF  x20,F
0406:  MOVF   x1E,W
0408:  ADDWF  x1F,F
040A:  BNC   043E
040C:  INCF   x20,F
040E:  BNZ   043E
0410:  INCF   x21,F
0412:  BNZ   043E
0414:  INCF   x22,F
0416:  BRA    043E
0418:  MOVF   x1C,W
041A:  IORLW  80
041C:  SUBWF  x21,F
041E:  BC    043C
0420:  MOVLW  01
0422:  SUBWF  x22,F
0424:  BC    043C
0426:  INCF   x22,F
0428:  MOVF   x1C,W
042A:  IORLW  80
042C:  ADDWF  x21,F
042E:  MOVF   x1D,W
0430:  ADDWF  x20,F
0432:  BNC   0406
0434:  INCF   x21,F
0436:  BNZ   0406
0438:  INCF   x22,F
043A:  BRA    0406
043C:  BSF    03.0
043E:  DECFSZ x23,F
0440:  BRA    0444
0442:  BRA    045A
0444:  BCF    FD8.0
0446:  RLCF   x1F,F
0448:  RLCF   x20,F
044A:  RLCF   x21,F
044C:  RLCF   x22,F
044E:  BCF    FD8.0
0450:  RLCF   03,F
0452:  RLCF   02,F
0454:  RLCF   01,F
0456:  RLCF   x24,F
0458:  BRA    03CE
045A:  BTFSS  x24.0
045C:  BRA    046A
045E:  BCF    FD8.0
0460:  RRCF   01,F
0462:  RRCF   02,F
0464:  RRCF   03,F
0466:  RRCF   x24,F
0468:  BRA    046E
046A:  DECF   00,F
046C:  BZ    04D8
046E:  BTFSC  x24.7
0470:  BRA    04AE
0472:  BCF    FD8.0
0474:  RLCF   x1F,F
0476:  RLCF   x20,F
0478:  RLCF   x21,F
047A:  RLCF   x22,F
047C:  MOVF   x1E,W
047E:  SUBWF  x1F,F
0480:  BC    0490
0482:  MOVLW  01
0484:  SUBWF  x20,F
0486:  BC    0490
0488:  SUBWF  x21,F
048A:  BC    0490
048C:  SUBWF  x22,F
048E:  BNC   04C4
0490:  MOVF   x1D,W
0492:  SUBWF  x20,F
0494:  BC    04A0
0496:  MOVLW  01
0498:  SUBWF  x21,F
049A:  BC    04A0
049C:  SUBWF  x22,F
049E:  BNC   04C4
04A0:  MOVF   x1C,W
04A2:  IORLW  80
04A4:  SUBWF  x21,F
04A6:  BC    04AE
04A8:  MOVLW  01
04AA:  SUBWF  x22,F
04AC:  BNC   04C4
04AE:  INCF   03,F
04B0:  BNZ   04C4
04B2:  INCF   02,F
04B4:  BNZ   04C4
04B6:  INCF   01,F
04B8:  BNZ   04C4
04BA:  INCF   00,F
04BC:  BZ    04D8
04BE:  RRCF   01,F
04C0:  RRCF   02,F
04C2:  RRCF   03,F
04C4:  MOVFF  118,123
04C8:  MOVF   x1C,W
04CA:  XORWF  x23,F
04CC:  BTFSS  x23.7
04CE:  BRA    04D4
04D0:  BSF    01.7
04D2:  BRA    04E0
04D4:  BCF    01.7
04D6:  BRA    04E0
04D8:  CLRF   00
04DA:  CLRF   01
04DC:  CLRF   02
04DE:  CLRF   03
04E0:  MOVLB  0
04E2:  RETURN 0
04E4:  MOVLB  1
04E6:  MOVF   x13,W
04E8:  BTFSC  FD8.2
04EA:  BRA    05CE
04EC:  MOVWF  00
04EE:  MOVF   x17,W
04F0:  BTFSC  FD8.2
04F2:  BRA    05CE
04F4:  ADDWF  00,F
04F6:  BNC   0500
04F8:  MOVLW  81
04FA:  ADDWF  00,F
04FC:  BC    05CE
04FE:  BRA    0508
0500:  MOVLW  7F
0502:  SUBWF  00,F
0504:  BNC   05CE
0506:  BZ    05CE
0508:  MOVFF  114,11B
050C:  MOVF   x18,W
050E:  XORWF  x1B,F
0510:  BSF    x14.7
0512:  BSF    x18.7
0514:  MOVF   x16,W
0516:  MULWF  x1A
0518:  MOVFF  FF4,11D
051C:  MOVF   x15,W
051E:  MULWF  x19
0520:  MOVFF  FF4,03
0524:  MOVFF  FF3,11C
0528:  MULWF  x1A
052A:  MOVF   FF3,W
052C:  ADDWF  x1D,F
052E:  MOVF   FF4,W
0530:  ADDWFC x1C,F
0532:  MOVLW  00
0534:  ADDWFC 03,F
0536:  MOVF   x16,W
0538:  MULWF  x19
053A:  MOVF   FF3,W
053C:  ADDWF  x1D,F
053E:  MOVF   FF4,W
0540:  ADDWFC x1C,F
0542:  MOVLW  00
0544:  CLRF   02
0546:  ADDWFC 03,F
0548:  ADDWFC 02,F
054A:  MOVF   x14,W
054C:  MULWF  x1A
054E:  MOVF   FF3,W
0550:  ADDWF  x1C,F
0552:  MOVF   FF4,W
0554:  ADDWFC 03,F
0556:  MOVLW  00
0558:  ADDWFC 02,F
055A:  MOVF   x14,W
055C:  MULWF  x19
055E:  MOVF   FF3,W
0560:  ADDWF  03,F
0562:  MOVF   FF4,W
0564:  ADDWFC 02,F
0566:  MOVLW  00
0568:  CLRF   01
056A:  ADDWFC 01,F
056C:  MOVF   x16,W
056E:  MULWF  x18
0570:  MOVF   FF3,W
0572:  ADDWF  x1C,F
0574:  MOVF   FF4,W
0576:  ADDWFC 03,F
0578:  MOVLW  00
057A:  ADDWFC 02,F
057C:  ADDWFC 01,F
057E:  MOVF   x15,W
0580:  MULWF  x18
0582:  MOVF   FF3,W
0584:  ADDWF  03,F
0586:  MOVF   FF4,W
0588:  ADDWFC 02,F
058A:  MOVLW  00
058C:  ADDWFC 01,F
058E:  MOVF   x14,W
0590:  MULWF  x18
0592:  MOVF   FF3,W
0594:  ADDWF  02,F
0596:  MOVF   FF4,W
0598:  ADDWFC 01,F
059A:  INCF   00,F
059C:  BTFSC  01.7
059E:  BRA    05AA
05A0:  RLCF   x1C,F
05A2:  RLCF   03,F
05A4:  RLCF   02,F
05A6:  RLCF   01,F
05A8:  DECF   00,F
05AA:  MOVLW  00
05AC:  BTFSS  x1C.7
05AE:  BRA    05C4
05B0:  INCF   03,F
05B2:  ADDWFC 02,F
05B4:  ADDWFC 01,F
05B6:  MOVF   01,W
05B8:  BNZ   05C4
05BA:  MOVF   02,W
05BC:  BNZ   05C4
05BE:  MOVF   03,W
05C0:  BNZ   05C4
05C2:  INCF   00,F
05C4:  BTFSC  x1B.7
05C6:  BSF    01.7
05C8:  BTFSS  x1B.7
05CA:  BCF    01.7
05CC:  BRA    05D6
05CE:  CLRF   00
05D0:  CLRF   01
05D2:  CLRF   02
05D4:  CLRF   03
05D6:  MOVLB  0
05D8:  RETURN 0
05DA:  MOVFF  114,11B
05DE:  MOVLB  1
05E0:  MOVF   x18,W
05E2:  XORWF  x1B,F
05E4:  BTFSS  x1B.7
05E6:  BRA    05F2
05E8:  BCF    FD8.2
05EA:  BCF    FD8.0
05EC:  BTFSC  x14.7
05EE:  BSF    FD8.0
05F0:  BRA    0650
05F2:  MOVFF  114,11B
05F6:  MOVFF  117,11C
05FA:  MOVF   x13,W
05FC:  SUBWF  x1C,F
05FE:  BZ    060C
0600:  BTFSS  x1B.7
0602:  BRA    0650
0604:  MOVF   FD8,W
0606:  XORLW  01
0608:  MOVWF  FD8
060A:  BRA    0650
060C:  MOVFF  118,11C
0610:  MOVF   x14,W
0612:  SUBWF  x1C,F
0614:  BZ    0622
0616:  BTFSS  x1B.7
0618:  BRA    0650
061A:  MOVF   FD8,W
061C:  XORLW  01
061E:  MOVWF  FD8
0620:  BRA    0650
0622:  MOVFF  119,11C
0626:  MOVF   x15,W
0628:  SUBWF  x1C,F
062A:  BZ    0638
062C:  BTFSS  x1B.7
062E:  BRA    0650
0630:  MOVF   FD8,W
0632:  XORLW  01
0634:  MOVWF  FD8
0636:  BRA    0650
0638:  MOVFF  11A,11C
063C:  MOVF   x16,W
063E:  SUBWF  x1C,F
0640:  BZ    064E
0642:  BTFSS  x1B.7
0644:  BRA    0650
0646:  MOVF   FD8,W
0648:  XORLW  01
064A:  MOVWF  FD8
064C:  BRA    0650
064E:  BCF    FD8.0
0650:  MOVLB  0
0652:  RETURN 0
0654:  MOVLW  8E
0656:  MOVWF  00
0658:  MOVLB  1
065A:  MOVF   x13,W
065C:  SUBWF  00,F
065E:  MOVFF  114,02
0662:  MOVFF  115,01
0666:  BSF    02.7
0668:  MOVF   00,F
066A:  BZ    067E
066C:  BCF    FD8.0
066E:  MOVF   02,F
0670:  BNZ   0676
0672:  MOVF   01,F
0674:  BZ    067E
0676:  RRCF   02,F
0678:  RRCF   01,F
067A:  DECFSZ 00,F
067C:  BRA    066C
067E:  BTFSS  x14.7
0680:  BRA    068C
0682:  COMF   01,F
0684:  COMF   02,F
0686:  INCF   01,F
0688:  BTFSC  FD8.2
068A:  INCF   02,F
068C:  MOVLB  0
068E:  RETURN 0
*
0DA4:  DATA 0D,0A
0DA6:  DATA 50,55
0DA8:  DATA 4C,53
0DAA:  DATA 4F,20
0DAC:  DATA 52,45
0DAE:  DATA 43,49
0DB0:  DATA 42,49
0DB2:  DATA 44,4F
0DB4:  DATA 20,2D
0DB6:  DATA 2D,2D
0DB8:  DATA 2D,2D
0DBA:  DATA 2D,2D
0DBC:  DATA 2D,2D
0DBE:  DATA 2D,2D
0DC0:  DATA 2D,2D
0DC2:  DATA 2D,2D
0DC4:  DATA 2D,2D
0DC6:  DATA 2D,2D
0DC8:  DATA 2D,2D
0DCA:  DATA 2D,2D
0DCC:  DATA 0D,0A
0DCE:  DATA 00,00
0DD0:  DATA 42,79
0DD2:  DATA 74,65
0DD4:  DATA 20,25
0DD6:  DATA 75,20
0DD8:  DATA 3D,20
0DDA:  DATA 0D,00
0DDC:  DATA 20,56
0DDE:  DATA 61,6C
0DE0:  DATA 6F,72
0DE2:  DATA 20,3D
0DE4:  DATA 20,25
0DE6:  DATA 75,0D
0DE8:  DATA 0A,00
0DEA:  DATA 41,64
0DEC:  DATA 64,72
0DEE:  DATA 65,73
0DF0:  DATA 73,20
0DF2:  DATA 3D,20
0DF4:  DATA 25,75
0DF6:  DATA 20,43
0DF8:  DATA 6F,6D
0DFA:  DATA 6D,61
0DFC:  DATA 6E,64
0DFE:  DATA 20,3D
0E00:  DATA 20,25
0E02:  DATA 75,0D
0E04:  DATA 0A,00
0E06:  DATA 42,79
0E08:  DATA 74,65
0E0A:  DATA 20,3D
0E0C:  DATA 20,0D
0E0E:  DATA 00,00
0E10:  DATA 48,6F
0E12:  DATA 6C,61
0E14:  DATA 20,53
0E16:  DATA 6F,79
0E18:  DATA 20,65
0E1A:  DATA 6C,20
0E1C:  DATA 52,6F
0E1E:  DATA 62,6F
0E20:  DATA 74,20
0E22:  DATA 43,55
0E24:  DATA 49,43
0E26:  DATA 55,49
0E28:  DATA 20,32
0E2A:  DATA 2E,30
0E2C:  DATA 20,3A
0E2E:  DATA 44,20
0E30:  DATA 25,73
0E32:  DATA 0D,0A
0E34:  DATA 00,00
0E36:  DATA 0D,0A
0E38:  DATA 56,6F
0E3A:  DATA 6C,74
0E3C:  DATA 61,67
0E3E:  DATA 65,20
0E40:  DATA 3D,20
0E42:  DATA 25,30
0E44:  DATA 31,2E
0E46:  DATA 32,66
0E48:  DATA 56,0D
0E4A:  DATA 0A,00
0E4C:  DATA 45,6D
0E4E:  DATA 69,74
0E50:  DATA 65,20
0E52:  DATA 75,6E
0E54:  DATA 20,73
0E56:  DATA 6F,6E
0E58:  DATA 69,64
0E5A:  DATA 6F,20
0E5C:  DATA 0D,00
*
0E86:  TBLRD*+
0E88:  MOVFF  FF6,ED
0E8C:  MOVFF  FF7,EE
0E90:  MOVF   FF5,W
0E92:  BTFSS  F9E.4
0E94:  BRA    0E92
0E96:  MOVWF  FAD
0E98:  MOVFF  ED,FF6
0E9C:  MOVFF  EE,FF7
0EA0:  DECFSZ xEC,F
0EA2:  BRA    0E86
0EA4:  RETURN 0
0EA6:  TBLRD*+
0EA8:  MOVF   FF5,F
0EAA:  BZ    0EC6
0EAC:  MOVFF  FF6,EC
0EB0:  MOVFF  FF7,ED
0EB4:  MOVF   FF5,W
0EB6:  BTFSS  F9E.4
0EB8:  BRA    0EB6
0EBA:  MOVWF  FAD
0EBC:  MOVFF  EC,FF6
0EC0:  MOVFF  ED,FF7
0EC4:  BRA    0EA6
0EC6:  RETURN 0
0EC8:  BTFSC  FD8.1
0ECA:  BRA    0ED4
0ECC:  MOVLW  01
0ECE:  MOVWF  FEA
0ED0:  MOVLW  0E
0ED2:  MOVWF  FE9
0ED4:  CLRF   00
0ED6:  CLRF   01
0ED8:  CLRF   02
0EDA:  CLRF   03
0EDC:  MOVLB  1
0EDE:  CLRF   x0E
0EE0:  CLRF   x0F
0EE2:  CLRF   x10
0EE4:  CLRF   x11
0EE6:  MOVF   x0D,W
0EE8:  IORWF  x0C,W
0EEA:  IORWF  x0B,W
0EEC:  IORWF  x0A,W
0EEE:  BZ    0F48
0EF0:  MOVLW  20
0EF2:  MOVWF  x12
0EF4:  BCF    FD8.0
0EF6:  RLCF   x06,F
0EF8:  RLCF   x07,F
0EFA:  RLCF   x08,F
0EFC:  RLCF   x09,F
0EFE:  RLCF   x0E,F
0F00:  RLCF   x0F,F
0F02:  RLCF   x10,F
0F04:  RLCF   x11,F
0F06:  MOVF   x0D,W
0F08:  SUBWF  x11,W
0F0A:  BNZ   0F1C
0F0C:  MOVF   x0C,W
0F0E:  SUBWF  x10,W
0F10:  BNZ   0F1C
0F12:  MOVF   x0B,W
0F14:  SUBWF  x0F,W
0F16:  BNZ   0F1C
0F18:  MOVF   x0A,W
0F1A:  SUBWF  x0E,W
0F1C:  BNC   0F3C
0F1E:  MOVF   x0A,W
0F20:  SUBWF  x0E,F
0F22:  MOVF   x0B,W
0F24:  BTFSS  FD8.0
0F26:  INCFSZ x0B,W
0F28:  SUBWF  x0F,F
0F2A:  MOVF   x0C,W
0F2C:  BTFSS  FD8.0
0F2E:  INCFSZ x0C,W
0F30:  SUBWF  x10,F
0F32:  MOVF   x0D,W
0F34:  BTFSS  FD8.0
0F36:  INCFSZ x0D,W
0F38:  SUBWF  x11,F
0F3A:  BSF    FD8.0
0F3C:  RLCF   00,F
0F3E:  RLCF   01,F
0F40:  RLCF   02,F
0F42:  RLCF   03,F
0F44:  DECFSZ x12,F
0F46:  BRA    0EF4
0F48:  MOVFF  10E,FEF
0F4C:  MOVFF  10F,FEC
0F50:  MOVFF  110,FEC
0F54:  MOVFF  111,FEC
0F58:  MOVLB  0
0F5A:  RETURN 0
0F5C:  CLRF   01
0F5E:  CLRF   02
0F60:  CLRF   00
0F62:  CLRF   03
0F64:  MOVLB  1
0F66:  MOVF   x01,W
0F68:  BNZ   0F6E
0F6A:  MOVF   x00,W
0F6C:  BZ    0FA2
0F6E:  MOVLW  10
0F70:  MOVWF  x02
0F72:  BCF    FD8.0
0F74:  MOVLB  0
0F76:  RLCF   xFE,F
0F78:  RLCF   xFF,F
0F7A:  RLCF   00,F
0F7C:  RLCF   03,F
0F7E:  MOVLB  1
0F80:  MOVF   x01,W
0F82:  SUBWF  03,W
0F84:  BNZ   0F8A
0F86:  MOVF   x00,W
0F88:  SUBWF  00,W
0F8A:  BNC   0F9A
0F8C:  MOVF   x00,W
0F8E:  SUBWF  00,F
0F90:  BTFSS  FD8.0
0F92:  DECF   03,F
0F94:  MOVF   x01,W
0F96:  SUBWF  03,F
0F98:  BSF    FD8.0
0F9A:  RLCF   01,F
0F9C:  RLCF   02,F
0F9E:  DECFSZ x02,F
0FA0:  BRA    0F72
0FA2:  MOVLB  0
0FA4:  RETURN 0
0FA6:  MOVLB  1
0FA8:  CLRF   x0A
0FAA:  CLRF   x0B
0FAC:  MOVLW  01
0FAE:  MOVWF  x0C
0FB0:  CLRF   FDA
0FB2:  CLRF   FD9
0FB4:  MOVWF  x0F
0FB6:  MOVLW  02
0FB8:  MOVWF  x0E
0FBA:  MOVLW  01
0FBC:  MOVWF  FEA
0FBE:  MOVLW  06
0FC0:  MOVWF  FE9
0FC2:  MOVFF  10F,FE2
0FC6:  MOVFF  10E,FE1
0FCA:  MOVFF  10C,10D
0FCE:  BCF    FD8.0
0FD0:  MOVF   FE5,W
0FD2:  MULWF  FEE
0FD4:  MOVF   FF3,W
0FD6:  ADDWFC x0A,F
0FD8:  MOVF   FF4,W
0FDA:  ADDWFC x0B,F
0FDC:  DECFSZ x0D,F
0FDE:  BRA    0FCE
0FE0:  MOVFF  10A,FDE
0FE4:  MOVFF  10B,10A
0FE8:  CLRF   x0B
0FEA:  BTFSC  FD8.0
0FEC:  INCF   x0B,F
0FEE:  INCF   x0E,F
0FF0:  BTFSC  FD8.2
0FF2:  INCF   x0F,F
0FF4:  INCF   x0C,F
0FF6:  MOVF   x0C,W
0FF8:  SUBLW  05
0FFA:  BNZ   0FBA
0FFC:  MOVLB  0
0FFE:  GOTO   11B4 (RETURN)
*
132A:  MOVF   xF9,W
132C:  SUBLW  B6
132E:  MOVWF  xF9
1330:  CLRF   03
1332:  MOVFF  FA,FD
1336:  BSF    xFA.7
1338:  BCF    FD8.0
133A:  RRCF   xFA,F
133C:  RRCF   xFB,F
133E:  RRCF   xFC,F
1340:  RRCF   03,F
1342:  RRCF   02,F
1344:  RRCF   01,F
1346:  RRCF   00,F
1348:  DECFSZ xF9,F
134A:  BRA    1338
134C:  BTFSS  xFD.7
134E:  BRA    1366
1350:  COMF   00,F
1352:  COMF   01,F
1354:  COMF   02,F
1356:  COMF   03,F
1358:  INCF   00,F
135A:  BTFSC  FD8.2
135C:  INCF   01,F
135E:  BTFSC  FD8.2
1360:  INCF   02,F
1362:  BTFSC  FD8.2
1364:  INCF   03,F
1366:  GOTO   13CA (RETURN)
136A:  MOVF   FE9,W
136C:  MOVWF  xF1
136E:  MOVF   xF0,W
1370:  MOVWF  xF3
1372:  BZ    13B8
1374:  CLRF   19
1376:  BTFSC  FF2.7
1378:  BSF    19.7
137A:  BCF    FF2.7
137C:  MOVFF  EF,116
1380:  MOVFF  EE,115
1384:  MOVFF  ED,114
1388:  MOVFF  EC,113
138C:  MOVLB  1
138E:  CLRF   x1A
1390:  CLRF   x19
1392:  MOVLW  20
1394:  MOVWF  x18
1396:  MOVLW  82
1398:  MOVWF  x17
139A:  MOVLB  0
139C:  CALL   04E4
13A0:  BTFSC  19.7
13A2:  BSF    FF2.7
13A4:  MOVFF  03,EF
13A8:  MOVFF  02,EE
13AC:  MOVFF  01,ED
13B0:  MOVFF  00,EC
13B4:  DECFSZ xF3,F
13B6:  BRA    1374
13B8:  MOVFF  EF,FC
13BC:  MOVFF  EE,FB
13C0:  MOVFF  ED,FA
13C4:  MOVFF  EC,F9
13C8:  BRA    132A
13CA:  MOVFF  03,EF
13CE:  MOVFF  02,EE
13D2:  MOVFF  01,ED
13D6:  MOVFF  00,EC
13DA:  BTFSS  xEF.7
13DC:  BRA    13F8
13DE:  DECF   xF1,F
13E0:  BSF    xF1.5
13E2:  COMF   xEC,F
13E4:  COMF   xED,F
13E6:  COMF   xEE,F
13E8:  COMF   xEF,F
13EA:  INCF   xEC,F
13EC:  BTFSC  FD8.2
13EE:  INCF   xED,F
13F0:  BTFSC  FD8.2
13F2:  INCF   xEE,F
13F4:  BTFSC  FD8.2
13F6:  INCF   xEF,F
13F8:  MOVLW  3B
13FA:  MOVWF  xF8
13FC:  MOVLW  9A
13FE:  MOVWF  xF7
1400:  MOVLW  CA
1402:  MOVWF  xF6
1404:  CLRF   xF5
1406:  MOVLW  0A
1408:  MOVWF  xF3
140A:  MOVF   xF0,W
140C:  BTFSC  FD8.2
140E:  INCF   xF1,F
1410:  BSF    FD8.1
1412:  CLRF   FEA
1414:  MOVLW  EC
1416:  MOVWF  FE9
1418:  MOVFF  EF,109
141C:  MOVFF  EE,108
1420:  MOVFF  ED,107
1424:  MOVFF  EC,106
1428:  MOVFF  F8,10D
142C:  MOVFF  F7,10C
1430:  MOVFF  F6,10B
1434:  MOVFF  F5,10A
1438:  RCALL  0EC8
143A:  MOVF   01,W
143C:  MOVF   00,F
143E:  BNZ   145E
1440:  INCF   xF0,W
1442:  SUBWF  xF3,W
1444:  BZ    145E
1446:  MOVF   xF1,W
1448:  BZ    1462
144A:  ANDLW  0F
144C:  SUBWF  xF3,W
144E:  BZ    1452
1450:  BC    14C8
1452:  BTFSC  xF1.7
1454:  BRA    14C8
1456:  BTFSC  xF1.6
1458:  BRA    1462
145A:  MOVLW  20
145C:  BRA    14BE
145E:  MOVLW  20
1460:  ANDWF  xF1,F
1462:  BTFSS  xF1.5
1464:  BRA    1480
1466:  BCF    xF1.5
1468:  MOVF   xF0,W
146A:  BTFSS  FD8.2
146C:  DECF   xF1,F
146E:  MOVF   00,W
1470:  MOVWF  xF1
1472:  MOVLW  2D
1474:  BTFSS  F9E.4
1476:  BRA    1474
1478:  MOVWF  FAD
147A:  MOVF   xF1,W
147C:  MOVWF  00
147E:  CLRF   xF1
1480:  MOVF   xF0,W
1482:  SUBWF  xF3,W
1484:  BNZ   149C
1486:  MOVF   00,W
1488:  MOVWF  xF1
148A:  MOVLW  2E
148C:  BTFSS  F9E.4
148E:  BRA    148C
1490:  MOVWF  FAD
1492:  MOVF   xF1,W
1494:  MOVWF  00
1496:  MOVLW  20
1498:  ANDWF  xF1,F
149A:  MOVLW  00
149C:  MOVLW  30
149E:  BTFSS  xF1.5
14A0:  BRA    14BE
14A2:  BCF    xF1.5
14A4:  MOVF   xF0,W
14A6:  BTFSS  FD8.2
14A8:  DECF   xF1,F
14AA:  MOVF   00,W
14AC:  MOVWF  xF1
14AE:  MOVLW  2D
14B0:  BTFSS  F9E.4
14B2:  BRA    14B0
14B4:  MOVWF  FAD
14B6:  MOVF   xF1,W
14B8:  MOVWF  00
14BA:  CLRF   xF1
14BC:  MOVLW  30
14BE:  ADDWF  00,F
14C0:  MOVF   00,W
14C2:  BTFSS  F9E.4
14C4:  BRA    14C2
14C6:  MOVWF  FAD
14C8:  BCF    FD8.1
14CA:  MOVFF  F8,109
14CE:  MOVFF  F7,108
14D2:  MOVFF  F6,107
14D6:  MOVFF  F5,106
14DA:  MOVLB  1
14DC:  CLRF   x0D
14DE:  CLRF   x0C
14E0:  CLRF   x0B
14E2:  MOVLW  0A
14E4:  MOVWF  x0A
14E6:  MOVLB  0
14E8:  RCALL  0EC8
14EA:  MOVFF  03,F8
14EE:  MOVFF  02,F7
14F2:  MOVFF  01,F6
14F6:  MOVFF  00,F5
14FA:  DECFSZ xF3,F
14FC:  BRA    1410
14FE:  GOTO   1C66 (RETURN)
*
20C2:  ADDWF  FE8,W
20C4:  CLRF   FF7
20C6:  RLCF   FF7,F
20C8:  ADDLW  DD
20CA:  MOVWF  FF6
20CC:  MOVLW  20
20CE:  ADDWFC FF7,F
20D0:  TBLRD*-
20D2:  MOVF   FF5,W
20D4:  MOVWF  FFA
20D6:  TBLRD*
20D8:  MOVF   FF5,W
20DA:  MOVWF  FF9
20DC:  DATA 62,1D
20DE:  DATA C2,1D
20E0:  DATA 92,1D
20E2:  DATA 48,1E
20E4:  DATA AA,1D
20E6:  DATA 48,1E
20E8:  DATA 7A,1D
20EA:  ADDWF  FE8,W
20EC:  CLRF   FF7
20EE:  RLCF   FF7,F
20F0:  ADDLW  05
20F2:  MOVWF  FF6
20F4:  MOVLW  21
20F6:  ADDWFC FF7,F
20F8:  TBLRD*-
20FA:  MOVF   FF5,W
20FC:  MOVWF  FFA
20FE:  TBLRD*
2100:  MOVF   FF5,W
2102:  MOVWF  FF9
2104:  DATA 3C,20
2106:  DATA 94,20
2108:  DATA 68,20
210A:  DATA A8,20
210C:  DATA 7E,20
210E:  DATA A8,20
2110:  DATA 52,20
....................  
.................... #list 
....................  
.................... #device adc=10 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES HS                       //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... //#FUSES BORV20                   //Brownout reset at 2.0V 
.................... #FUSES PUT                      //Power Up Timer 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES STVREN                   //Stack full/underflow will cause reset 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NOWRTD                   //Data EEPROM not write protected 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES NOPBADEN                 //PORTB pins are configured as digital I/O on RESET 
.................... #FUSES NOWRTC                   //configuration not registers write protected 
.................... #FUSES NOWRTB                   //Boot block not write protected 
.................... #FUSES NOEBTR                   //Memory not protected from table reads 
.................... #FUSES NOEBTRB                  //Boot block not protected from table reads 
.................... #FUSES NOCPB                    //No Boot Block code protection 
.................... #FUSES NOLPT1OSC                //Timer1 configured for higher power operation 
.................... #FUSES NOMCLR                   //Master Clear pin used for I/O 
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES CCP2B3 
....................  
.................... #use delay(clock=20000000) 
*
0E5E:  MOVLW  01
0E60:  MOVWF  FEA
0E62:  MOVLW  03
0E64:  MOVWF  FE9
0E66:  MOVF   FEF,W
0E68:  BZ    0E84
0E6A:  MOVLW  06
0E6C:  MOVWF  01
0E6E:  CLRF   00
0E70:  DECFSZ 00,F
0E72:  BRA    0E70
0E74:  DECFSZ 01,F
0E76:  BRA    0E6E
0E78:  MOVLW  7B
0E7A:  MOVWF  00
0E7C:  DECFSZ 00,F
0E7E:  BRA    0E7C
0E80:  DECFSZ FEF,F
0E82:  BRA    0E6A
0E84:  RETURN 0
*
1002:  MOVLW  03
1004:  MOVLB  1
1006:  SUBWF  x03,F
1008:  BNC   101E
100A:  MOVLW  01
100C:  MOVWF  FEA
100E:  MOVLW  03
1010:  MOVWF  FE9
1012:  MOVF   FEF,W
1014:  BZ    101E
1016:  BRA    101A
1018:  BRA    101A
101A:  DECFSZ FEF,F
101C:  BRA    1018
101E:  MOVLB  0
1020:  RETURN 0
.................... #use rs232(BAUD=57600,BITS=8 ,PARITY=N,XMIT=PIN_C6,RCV=PIN_C7) 
....................  
....................  
....................  
.................... #byte T1CON = 0x0FCD 
.................... #byte PIR2 = 0x0FA1 
.................... #bit  TMR3IF =PIR2.1 
.................... #define  MUSIC_NOTES TRUE 
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <tones_c5.c>  
.................... ////////////////// Driver to generate musical tones ///////////////////// 
.................... ////                                                                 //// 
.................... ////  generate_tone(frequency, duration)     Generates wave at set   //// 
.................... ////                                         frequency (Hz) for set  //// 
.................... ////                                         duration (ms)           //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... //#ifndef  MUSIC_NOTES 
.................... //#define  MUSIC_NOTES 
....................  
.................... //            NOTE                 FREQUENCY 
.................... //                     Octave0  Octave1  Octave2  Octave3 
.................... const long C_NOTE[4]  ={ 262,     523,    1047,    2093}; 
.................... const long Db_NOTE[4] ={ 277,     554,    1109,    2217}; 
.................... const long D_NOTE[4]  ={ 294,     587,    1175,    2349}; 
.................... const long Eb_NOTE[4] ={ 311,     622,    1245,    2489}; 
.................... const long E_NOTE[4]  ={ 330,     659,    1329,    2637}; 
.................... const long F_NOTE[4]  ={ 349,     698,    1397,    2794}; 
.................... const long Gb_NOTE[4] ={ 370,     740,    1480,    2960}; 
.................... const long G_NOTE[4]  ={ 392,     784,    1568,    3136}; 
.................... const long Ab_NOTE[4] ={ 415,     831,    1661,    3322}; 
.................... const long A_NOTE[4]  ={ 440,     880,    1760,    3520}; 
.................... const long Bb_NOTE[4] ={ 466,     923,    1865,    3729}; 
.................... const long B_NOTE[4]  ={ 494,     988,    1976,    3951}; 
.................... //#endif 
....................  
.................... #define TONE_PIN  PIN_A5 
....................  
....................  
.................... void do_delay(int ms_delay, int num_ms, int us_delay, int num_us)  { 
....................  int i; 
....................  
....................  for(i=0;i<num_ms;i++) 
1022:  MOVLB  1
1024:  CLRF   x02
1026:  MOVLB  0
1028:  MOVF   xFF,W
102A:  MOVLB  1
102C:  SUBWF  x02,W
102E:  BC    103E
....................   delay_ms(250); 
1030:  MOVLW  FA
1032:  MOVWF  x03
1034:  MOVLB  0
1036:  RCALL  0E5E
1038:  MOVLB  1
103A:  INCF   x02,F
103C:  BRA    1026
....................  delay_ms(ms_delay); 
103E:  MOVFF  FE,103
1042:  MOVLB  0
1044:  RCALL  0E5E
....................  for(i=0;i<num_us;i++) 
1046:  MOVLB  1
1048:  CLRF   x02
104A:  MOVF   x01,W
104C:  SUBWF  x02,W
104E:  BC    105E
....................   delay_us(250); 
1050:  MOVLW  FA
1052:  MOVWF  x03
1054:  MOVLB  0
1056:  RCALL  1002
1058:  MOVLB  1
105A:  INCF   x02,F
105C:  BRA    104A
....................  delay_us(us_delay); 
105E:  MOVFF  100,103
1062:  MOVLB  0
1064:  RCALL  1002
1066:  RETURN 0
.................... } 
....................  
....................  
.................... void generate_tone(long frequency, long duration) 
.................... { 
....................    int32 total_delay_time;                      // in microseconds 
....................    long total_ms_delay_time, total_us_delay_time; 
....................    int num_us_delays, num_ms_delays, ms_delay_time, us_delay_time; 
....................    long num_periods; 
....................  
....................    total_delay_time = (1000000/frequency)/2-10; // calculate total delay time (10 for error) 
1068:  BCF    FD8.1
106A:  MOVLB  1
106C:  CLRF   x09
106E:  MOVLW  0F
1070:  MOVWF  x08
1072:  MOVLW  42
1074:  MOVWF  x07
1076:  MOVLW  40
1078:  MOVWF  x06
107A:  CLRF   x0D
107C:  CLRF   x0C
107E:  MOVFF  ED,10B
1082:  MOVFF  EC,10A
1086:  MOVLB  0
1088:  RCALL  0EC8
108A:  MOVFF  03,101
108E:  MOVFF  02,100
1092:  MOVFF  01,FF
1096:  MOVFF  00,FE
109A:  BCF    FD8.0
109C:  MOVLB  1
109E:  RRCF   x01,F
10A0:  RRCF   x00,F
10A2:  MOVLB  0
10A4:  RRCF   xFF,F
10A6:  RRCF   xFE,F
10A8:  MOVLW  0A
10AA:  SUBWF  xFE,W
10AC:  MOVWF  xF0
10AE:  MOVLW  00
10B0:  SUBWFB xFF,W
10B2:  MOVWF  xF1
10B4:  MOVLW  00
10B6:  MOVLB  1
10B8:  SUBWFB x00,W
10BA:  MOVLB  0
10BC:  MOVWF  xF2
10BE:  MOVLW  00
10C0:  MOVLB  1
10C2:  SUBWFB x01,W
10C4:  MOVLB  0
10C6:  MOVWF  xF3
....................  
....................    total_ms_delay_time = total_delay_time/1000; // total delay time of ms 
10C8:  BCF    FD8.1
10CA:  MOVFF  F3,109
10CE:  MOVFF  F2,108
10D2:  MOVFF  F1,107
10D6:  MOVFF  F0,106
10DA:  MOVLB  1
10DC:  CLRF   x0D
10DE:  CLRF   x0C
10E0:  MOVLW  03
10E2:  MOVWF  x0B
10E4:  MOVLW  E8
10E6:  MOVWF  x0A
10E8:  MOVLB  0
10EA:  RCALL  0EC8
10EC:  MOVFF  01,F5
10F0:  MOVFF  00,F4
....................    num_ms_delays = total_ms_delay_time/250;     // number of 250ms delays needed 
10F4:  MOVFF  F5,FF
10F8:  MOVFF  F4,FE
10FC:  MOVLB  1
10FE:  CLRF   x01
1100:  MOVLW  FA
1102:  MOVWF  x00
1104:  MOVLB  0
1106:  RCALL  0F5C
1108:  MOVFF  01,F9
....................    ms_delay_time = total_ms_delay_time%250;     // left over ms delay time needed 
110C:  MOVFF  F5,FF
1110:  MOVFF  F4,FE
1114:  MOVLB  1
1116:  CLRF   x01
1118:  MOVLW  FA
111A:  MOVWF  x00
111C:  MOVLB  0
111E:  RCALL  0F5C
1120:  MOVFF  00,FA
....................  
....................    total_us_delay_time = total_delay_time%1000; // total delay time of us (ms already acounted for) 
1124:  BSF    FD8.1
1126:  CLRF   FEA
1128:  MOVLW  FE
112A:  MOVWF  FE9
112C:  MOVFF  F3,109
1130:  MOVFF  F2,108
1134:  MOVFF  F1,107
1138:  MOVFF  F0,106
113C:  MOVLB  1
113E:  CLRF   x0D
1140:  CLRF   x0C
1142:  MOVLW  03
1144:  MOVWF  x0B
1146:  MOVLW  E8
1148:  MOVWF  x0A
114A:  MOVLB  0
114C:  RCALL  0EC8
114E:  MOVFF  FF,F7
1152:  MOVFF  FE,F6
....................    num_us_delays = total_us_delay_time/250;     // number of 250us delays needed 
1156:  MOVFF  F7,FF
115A:  MOVFF  F6,FE
115E:  MOVLB  1
1160:  CLRF   x01
1162:  MOVLW  FA
1164:  MOVWF  x00
1166:  MOVLB  0
1168:  RCALL  0F5C
116A:  MOVFF  01,F8
....................    us_delay_time = total_us_delay_time%250;     // left over us delay time needed 
116E:  MOVFF  F7,FF
1172:  MOVFF  F6,FE
1176:  MOVLB  1
1178:  CLRF   x01
117A:  MOVLW  FA
117C:  MOVWF  x00
117E:  MOVLB  0
1180:  RCALL  0F5C
1182:  MOVFF  00,FB
....................  
....................    num_periods = ((int32)duration*1000)/(1000000/frequency); 
1186:  MOVLB  1
1188:  CLRF   x01
118A:  CLRF   x00
118C:  MOVFF  EF,FF
1190:  MOVFF  EE,FE
1194:  MOVFF  101,105
1198:  MOVFF  100,104
119C:  MOVFF  EF,103
11A0:  MOVFF  EE,102
11A4:  CLRF   x09
11A6:  CLRF   x08
11A8:  MOVLW  03
11AA:  MOVWF  x07
11AC:  MOVLW  E8
11AE:  MOVWF  x06
11B0:  MOVLB  0
11B2:  BRA    0FA6
11B4:  MOVFF  03,101
11B8:  MOVFF  02,100
11BC:  MOVFF  01,FF
11C0:  MOVFF  00,FE
11C4:  BCF    FD8.1
11C6:  MOVLB  1
11C8:  CLRF   x09
11CA:  MOVLW  0F
11CC:  MOVWF  x08
11CE:  MOVLW  42
11D0:  MOVWF  x07
11D2:  MOVLW  40
11D4:  MOVWF  x06
11D6:  CLRF   x0D
11D8:  CLRF   x0C
11DA:  MOVFF  ED,10B
11DE:  MOVFF  EC,10A
11E2:  MOVLB  0
11E4:  RCALL  0EC8
11E6:  MOVFF  03,105
11EA:  MOVFF  02,104
11EE:  MOVFF  01,103
11F2:  MOVFF  00,102
11F6:  BCF    FD8.1
11F8:  MOVFF  101,109
11FC:  MOVFF  100,108
1200:  MOVFF  FF,107
1204:  MOVFF  FE,106
1208:  MOVFF  03,10D
120C:  MOVFF  02,10C
1210:  MOVFF  01,10B
1214:  MOVFF  00,10A
1218:  RCALL  0EC8
121A:  MOVFF  01,FD
121E:  MOVFF  00,FC
....................  
....................    while((num_periods--) != 0) 
1222:  MOVFF  FD,FF
1226:  MOVF   xFC,W
1228:  BTFSC  FD8.2
122A:  DECF   xFD,F
122C:  DECF   xFC,F
122E:  MOVWF  xFE
1230:  MOVF   xFE,F
1232:  BNZ   1238
1234:  MOVF   xFF,F
1236:  BZ    1266
....................    { 
....................       do_delay(ms_delay_time, num_ms_delays, us_delay_time, num_us_delays); 
1238:  MOVFF  FA,FE
123C:  MOVFF  F9,FF
1240:  MOVFF  FB,100
1244:  MOVFF  F8,101
1248:  RCALL  1022
....................       output_high(TONE_PIN); 
124A:  BCF    F92.5
124C:  BSF    F89.5
....................       do_delay(ms_delay_time, num_ms_delays, us_delay_time, num_us_delays); 
124E:  MOVFF  FA,FE
1252:  MOVFF  F9,FF
1256:  MOVFF  FB,100
125A:  MOVFF  F8,101
125E:  RCALL  1022
....................       output_low(TONE_PIN); 
1260:  BCF    F92.5
1262:  BCF    F89.5
1264:  BRA    1222
....................    } 
....................  
....................    return; 
1266:  RETURN 0
.................... } 
....................  
.................... //#define  MUSIC_NOTES TRUE 
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
....................  
.................... //Se agrega el caracter nulo al final de una asignacion de tipo string 
....................  
.................... const char Version[]="1.0\0";     
.................... const int total_bits=10; 
.................... const int total_bytes=2; 
.................... const int total_datos=25; 
.................... const int UP=2; 
.................... const int SOUND=3; 
.................... const int LEFT=4; 
.................... const int GO=5; 
.................... const int RIGHT=6; 
.................... //const int PAUSE=7; 
.................... const int DOWN=8; 
.................... const int RESET=9; 
.................... const int16 mov_recto=300, mov_giro=200; 
....................  
.................... const int vel1=10; 
.................... const int vel2=15; 
.................... const int vel3=20; 
....................  
....................  
....................  
.................... int  mov_ant=0, mov_act=0; 
.................... int  datos[total_datos]="\0"; 
....................  
.................... int8 valorR; 
....................  
.................... int16 q, level_ir_b, level_source_b, distancia_0, distancia_1, diferencia_T0, diferencia_T1, distancia_recorrida_1=0, distancia_recorrida_2=0;  
.................... int16 control_M1, control_M2, valor_pwm=0, vel_pwm=0; 
.................... int16 T0_Act=0, T1_Act=0, T0_Ant=0, T1_Ant=0, Delta_T0=0, Delta_T1=0, Delta_T0_ant=0;  
.................... int16 counter_sleep=0; 
....................  
.................... float p, level_ir, level_source; 
.................... const float a=72.0, b=0.6, c=0.15, a2=10.0, b2=0.2, c2=0.015;  //b=0 
.................... float rV, eV, iV, dV, yV, uV, iV0, eV0, uV2; 
.................... float eD, iD, dD, iD0, eD0, uD; 
.................... const float max=1000.0, min=0.0; 
.................... float velocidad_ref=0, delta_recorrido=0, velocidad_T0=0; 
....................  
....................  
.................... long times_cr[total_bits]="\0"; 
.................... char sbits[total_bits]; 
.................... int1 first_ext=0; 
.................... int1 start_recived=0; 
.................... int i,j,k; 
.................... long tt,tti,t; 
.................... int ntbits=0; 
.................... int1 hay_dato=0; 
.................... int contador=0; 
.................... int bits[8]={0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80}; 
.................... int bytes[total_bytes]={0x00,0x00}; 
.................... int identificador=0x01; 
.................... int dato_ir=0x00; 
.................... int1 wake_up=0, out_sleep=0; 
.................... int1 temp; 
.................... int1 control_tipo; 
.................... //void limpia_bits(void); 
....................  
.................... void limpia_bits(void){ 
....................  
....................   for(i=0;i<total_bits;++i){ 
*
0CBC:  CLRF   xD3
0CBE:  MOVF   xD3,W
0CC0:  SUBLW  09
0CC2:  BNC   0CD8
....................     sbits[i]='\0'; 
0CC4:  CLRF   03
0CC6:  MOVF   xD3,W
0CC8:  ADDLW  C8
0CCA:  MOVWF  FE9
0CCC:  MOVLW  00
0CCE:  ADDWFC 03,W
0CD0:  MOVWF  FEA
0CD2:  CLRF   FEF
0CD4:  INCF   xD3,F
0CD6:  BRA    0CBE
....................   } 
....................   ntbits=0; 
0CD8:  CLRF   xDC
0CDA:  RETURN 0
.................... } 
.................... // INTERRUPCION POR TIMER 3 
.................... #int_timer3 
.................... void timer3_isr(){ 
....................  
.................... set_timer3(34285); 
*
0690:  MOVLW  85
0692:  MOVWF  FB3
0694:  MOVLW  ED
0696:  MOVWF  FB2
....................  
.................... T0_Act=get_timer0(); 
0698:  MOVF   FD6,W
069A:  MOVWF  50
069C:  MOVFF  FD7,51
....................  
.................... T1_Act=get_timer1(); 
06A0:  MOVF   FCE,W
06A2:  MOVWF  52
06A4:  MOVFF  FCF,53
....................  
.................... Delta_T0 = T0_Act - T0_Ant; 
06A8:  MOVF   54,W
06AA:  SUBWF  50,W
06AC:  MOVWF  58
06AE:  MOVF   55,W
06B0:  SUBWFB 51,W
06B2:  MOVWF  59
.................... Delta_T1 = T1_Act - T1_Ant; 
06B4:  MOVF   56,W
06B6:  SUBWF  52,W
06B8:  MOVWF  5A
06BA:  MOVF   57,W
06BC:  SUBWFB 53,W
06BE:  MOVWF  5B
.................... velocidad_T0=((float)(Delta_T0)+(float)(Delta_T0_ant))/2; 
06C0:  MOVFF  59,118
06C4:  MOVFF  58,117
06C8:  RCALL  00D8
06CA:  MOVFF  03,116
06CE:  MOVFF  02,115
06D2:  MOVFF  01,114
06D6:  MOVFF  00,113
06DA:  MOVFF  5D,118
06DE:  MOVFF  5C,117
06E2:  RCALL  00D8
06E4:  BCF    FD8.1
06E6:  MOVFF  116,11A
06EA:  MOVFF  115,119
06EE:  MOVFF  114,118
06F2:  MOVFF  113,117
06F6:  MOVFF  03,11E
06FA:  MOVFF  02,11D
06FE:  MOVFF  01,11C
0702:  MOVFF  00,11B
0706:  RCALL  010E
0708:  MOVFF  03,116
070C:  MOVFF  02,115
0710:  MOVFF  01,114
0714:  MOVFF  00,113
0718:  MOVFF  03,11A
071C:  MOVFF  02,119
0720:  MOVFF  01,118
0724:  MOVFF  00,117
0728:  MOVLB  1
072A:  CLRF   x1E
072C:  CLRF   x1D
072E:  CLRF   x1C
0730:  MOVLW  80
0732:  MOVWF  x1B
0734:  MOVLB  0
0736:  RCALL  0386
0738:  MOVFF  03,B3
073C:  MOVFF  02,B2
0740:  MOVFF  01,B1
0744:  MOVFF  00,B0
....................  
.................... Delta_T0_ant=Delta_T0; 
0748:  MOVFF  59,5D
074C:  MOVFF  58,5C
.................... T0_Ant=T0_Act; 
0750:  MOVFF  51,55
0754:  MOVFF  50,54
.................... T1_Ant=T1_Act; 
0758:  MOVFF  53,57
075C:  MOVFF  52,56
.................... distancia_recorrida_1 = distancia_recorrida_1 + Delta_T0; 
0760:  MOVF   58,W
0762:  ADDWF  44,F
0764:  MOVF   59,W
0766:  ADDWFC 45,F
.................... distancia_recorrida_2 = distancia_recorrida_2 + Delta_T1; 
0768:  MOVF   5A,W
076A:  ADDWF  46,F
076C:  MOVF   5B,W
076E:  ADDWFC 47,F
.................... //printf("%2.2f,%3.1f\r",velocidad_T0, eD); 
.................... //printf("\r\nCorriente = %1.3fA\r\n", corriente_M1); 
.................... //printf("%Lu,%2.2f\r", Delta_T0, velocidad_T0); 
.................... //printf("%Lu,%Lu,%Lu,%Lu\r", Delta_T0, Delta_T1, distancia_recorrida_1, distancia_recorrida_2); 
....................  
....................        
....................       yV=Delta_T0; 
0770:  MOVFF  59,118
0774:  MOVFF  58,117
0778:  RCALL  00D8
077A:  MOVFF  03,7F
077E:  MOVFF  02,7E
0782:  MOVFF  01,7D
0786:  MOVFF  00,7C
....................       
....................       
....................      //rV=Velocidad_ref; 
....................      rV=30.0; 
078A:  CLRF   6F
078C:  CLRF   6E
078E:  MOVLW  70
0790:  MOVWF  6D
0792:  MOVLW  83
0794:  MOVWF  6C
....................      eV=rV - yV; 
0796:  BSF    FD8.1
0798:  MOVFF  6F,11A
079C:  MOVFF  6E,119
07A0:  MOVFF  6D,118
07A4:  MOVFF  6C,117
07A8:  MOVFF  7F,11E
07AC:  MOVFF  7E,11D
07B0:  MOVFF  7D,11C
07B4:  MOVFF  7C,11B
07B8:  RCALL  010E
07BA:  MOVFF  03,73
07BE:  MOVFF  02,72
07C2:  MOVFF  01,71
07C6:  MOVFF  00,70
....................      iV=b*eV + iV0; 
07CA:  MOVLW  9A
07CC:  MOVLB  1
07CE:  MOVWF  x16
07D0:  MOVLW  99
07D2:  MOVWF  x15
07D4:  MOVLW  19
07D6:  MOVWF  x14
07D8:  MOVLW  7E
07DA:  MOVWF  x13
07DC:  MOVFF  73,11A
07E0:  MOVFF  72,119
07E4:  MOVFF  71,118
07E8:  MOVFF  70,117
07EC:  MOVLB  0
07EE:  RCALL  04E4
07F0:  MOVFF  03,116
07F4:  MOVFF  02,115
07F8:  MOVFF  01,114
07FC:  MOVFF  00,113
0800:  BCF    FD8.1
0802:  MOVFF  03,11A
0806:  MOVFF  02,119
080A:  MOVFF  01,118
080E:  MOVFF  00,117
0812:  MOVFF  87,11E
0816:  MOVFF  86,11D
081A:  MOVFF  85,11C
081E:  MOVFF  84,11B
0822:  RCALL  010E
0824:  MOVFF  03,77
0828:  MOVFF  02,76
082C:  MOVFF  01,75
0830:  MOVFF  00,74
....................      dV=c*(eV-eV0); 
0834:  BSF    FD8.1
0836:  MOVFF  73,11A
083A:  MOVFF  72,119
083E:  MOVFF  71,118
0842:  MOVFF  70,117
0846:  MOVFF  8B,11E
084A:  MOVFF  8A,11D
084E:  MOVFF  89,11C
0852:  MOVFF  88,11B
0856:  RCALL  010E
0858:  MOVLW  9A
085A:  MOVLB  1
085C:  MOVWF  x16
085E:  MOVLW  99
0860:  MOVWF  x15
0862:  MOVLW  19
0864:  MOVWF  x14
0866:  MOVLW  7C
0868:  MOVWF  x13
086A:  MOVFF  03,11A
086E:  MOVFF  02,119
0872:  MOVFF  01,118
0876:  MOVFF  00,117
087A:  MOVLB  0
087C:  RCALL  04E4
087E:  MOVFF  03,7B
0882:  MOVFF  02,7A
0886:  MOVFF  01,79
088A:  MOVFF  00,78
....................      uV=iV + a*eV + dV; 
088E:  MOVLB  1
0890:  CLRF   x16
0892:  CLRF   x15
0894:  MOVLW  10
0896:  MOVWF  x14
0898:  MOVLW  85
089A:  MOVWF  x13
089C:  MOVFF  73,11A
08A0:  MOVFF  72,119
08A4:  MOVFF  71,118
08A8:  MOVFF  70,117
08AC:  MOVLB  0
08AE:  RCALL  04E4
08B0:  BCF    FD8.1
08B2:  MOVFF  77,11A
08B6:  MOVFF  76,119
08BA:  MOVFF  75,118
08BE:  MOVFF  74,117
08C2:  MOVFF  03,11E
08C6:  MOVFF  02,11D
08CA:  MOVFF  01,11C
08CE:  MOVFF  00,11B
08D2:  RCALL  010E
08D4:  MOVFF  03,116
08D8:  MOVFF  02,115
08DC:  MOVFF  01,114
08E0:  MOVFF  00,113
08E4:  BCF    FD8.1
08E6:  MOVFF  03,11A
08EA:  MOVFF  02,119
08EE:  MOVFF  01,118
08F2:  MOVFF  00,117
08F6:  MOVFF  7B,11E
08FA:  MOVFF  7A,11D
08FE:  MOVFF  79,11C
0902:  MOVFF  78,11B
0906:  RCALL  010E
0908:  MOVFF  03,83
090C:  MOVFF  02,82
0910:  MOVFF  01,81
0914:  MOVFF  00,80
....................       
....................      if (uV>max){ 
0918:  MOVLB  1
091A:  CLRF   x16
091C:  CLRF   x15
091E:  MOVLW  7A
0920:  MOVWF  x14
0922:  MOVLW  88
0924:  MOVWF  x13
0926:  MOVFF  83,11A
092A:  MOVFF  82,119
092E:  MOVFF  81,118
0932:  MOVFF  80,117
0936:  MOVLB  0
0938:  RCALL  05DA
093A:  BNC   094A
....................          uV=max;} 
093C:  CLRF   x83
093E:  CLRF   x82
0940:  MOVLW  7A
0942:  MOVWF  x81
0944:  MOVLW  88
0946:  MOVWF  x80
0948:  BRA    0972
....................      else { 
....................          if (uV<min){ 
094A:  MOVFF  83,116
094E:  MOVFF  82,115
0952:  MOVFF  81,114
0956:  MOVFF  80,113
095A:  MOVLB  1
095C:  CLRF   x1A
095E:  CLRF   x19
0960:  CLRF   x18
0962:  CLRF   x17
0964:  MOVLB  0
0966:  RCALL  05DA
0968:  BNC   0972
....................          uV=min;} 
096A:  CLRF   x83
096C:  CLRF   x82
096E:  CLRF   x81
0970:  CLRF   x80
....................           } 
....................      control_M1=uV; 
0972:  MOVFF  83,116
0976:  MOVFF  82,115
097A:  MOVFF  81,114
097E:  MOVFF  80,113
0982:  RCALL  0654
0984:  MOVFF  02,49
0988:  MOVFF  01,48
....................       
....................      eD=(float)(get_timer0()) - (float)(get_timer1()); 
098C:  MOVF   FD6,W
098E:  MOVFF  FD7,03
0992:  MOVLB  1
0994:  MOVWF  x17
0996:  MOVFF  FD7,118
099A:  MOVLB  0
099C:  CALL   00D8
09A0:  MOVFF  03,116
09A4:  MOVFF  02,115
09A8:  MOVFF  01,114
09AC:  MOVFF  00,113
09B0:  MOVF   FCE,W
09B2:  MOVFF  FCF,03
09B6:  MOVLB  1
09B8:  MOVWF  x17
09BA:  MOVFF  FCF,118
09BE:  MOVLB  0
09C0:  CALL   00D8
09C4:  BSF    FD8.1
09C6:  MOVFF  116,11A
09CA:  MOVFF  115,119
09CE:  MOVFF  114,118
09D2:  MOVFF  113,117
09D6:  MOVFF  03,11E
09DA:  MOVFF  02,11D
09DE:  MOVFF  01,11C
09E2:  MOVFF  00,11B
09E6:  CALL   010E
09EA:  MOVFF  03,93
09EE:  MOVFF  02,92
09F2:  MOVFF  01,91
09F6:  MOVFF  00,90
....................      iD=b2*eD + iD0; 
09FA:  MOVLW  CD
09FC:  MOVLB  1
09FE:  MOVWF  x16
0A00:  MOVLW  CC
0A02:  MOVWF  x15
0A04:  MOVLW  4C
0A06:  MOVWF  x14
0A08:  MOVLW  7C
0A0A:  MOVWF  x13
0A0C:  MOVFF  93,11A
0A10:  MOVFF  92,119
0A14:  MOVFF  91,118
0A18:  MOVFF  90,117
0A1C:  MOVLB  0
0A1E:  RCALL  04E4
0A20:  MOVFF  03,116
0A24:  MOVFF  02,115
0A28:  MOVFF  01,114
0A2C:  MOVFF  00,113
0A30:  BCF    FD8.1
0A32:  MOVFF  03,11A
0A36:  MOVFF  02,119
0A3A:  MOVFF  01,118
0A3E:  MOVFF  00,117
0A42:  MOVFF  9F,11E
0A46:  MOVFF  9E,11D
0A4A:  MOVFF  9D,11C
0A4E:  MOVFF  9C,11B
0A52:  CALL   010E
0A56:  MOVFF  03,97
0A5A:  MOVFF  02,96
0A5E:  MOVFF  01,95
0A62:  MOVFF  00,94
....................      dD=c2*(eD-eD0); 
0A66:  BSF    FD8.1
0A68:  MOVFF  93,11A
0A6C:  MOVFF  92,119
0A70:  MOVFF  91,118
0A74:  MOVFF  90,117
0A78:  MOVFF  A3,11E
0A7C:  MOVFF  A2,11D
0A80:  MOVFF  A1,11C
0A84:  MOVFF  A0,11B
0A88:  CALL   010E
0A8C:  MOVLW  8F
0A8E:  MOVLB  1
0A90:  MOVWF  x16
0A92:  MOVLW  C2
0A94:  MOVWF  x15
0A96:  MOVLW  75
0A98:  MOVWF  x14
0A9A:  MOVLW  78
0A9C:  MOVWF  x13
0A9E:  MOVFF  03,11A
0AA2:  MOVFF  02,119
0AA6:  MOVFF  01,118
0AAA:  MOVFF  00,117
0AAE:  MOVLB  0
0AB0:  RCALL  04E4
0AB2:  MOVFF  03,9B
0AB6:  MOVFF  02,9A
0ABA:  MOVFF  01,99
0ABE:  MOVFF  00,98
....................      uD=iD + a2*eD + dD; 
0AC2:  MOVLB  1
0AC4:  CLRF   x16
0AC6:  CLRF   x15
0AC8:  MOVLW  20
0ACA:  MOVWF  x14
0ACC:  MOVLW  82
0ACE:  MOVWF  x13
0AD0:  MOVFF  93,11A
0AD4:  MOVFF  92,119
0AD8:  MOVFF  91,118
0ADC:  MOVFF  90,117
0AE0:  MOVLB  0
0AE2:  RCALL  04E4
0AE4:  BCF    FD8.1
0AE6:  MOVFF  97,11A
0AEA:  MOVFF  96,119
0AEE:  MOVFF  95,118
0AF2:  MOVFF  94,117
0AF6:  MOVFF  03,11E
0AFA:  MOVFF  02,11D
0AFE:  MOVFF  01,11C
0B02:  MOVFF  00,11B
0B06:  CALL   010E
0B0A:  MOVFF  03,116
0B0E:  MOVFF  02,115
0B12:  MOVFF  01,114
0B16:  MOVFF  00,113
0B1A:  BCF    FD8.1
0B1C:  MOVFF  03,11A
0B20:  MOVFF  02,119
0B24:  MOVFF  01,118
0B28:  MOVFF  00,117
0B2C:  MOVFF  9B,11E
0B30:  MOVFF  9A,11D
0B34:  MOVFF  99,11C
0B38:  MOVFF  98,11B
0B3C:  CALL   010E
0B40:  MOVFF  03,A7
0B44:  MOVFF  02,A6
0B48:  MOVFF  01,A5
0B4C:  MOVFF  00,A4
....................       
....................      uV2 = uV + uD; 
0B50:  BCF    FD8.1
0B52:  MOVFF  83,11A
0B56:  MOVFF  82,119
0B5A:  MOVFF  81,118
0B5E:  MOVFF  80,117
0B62:  MOVFF  A7,11E
0B66:  MOVFF  A6,11D
0B6A:  MOVFF  A5,11C
0B6E:  MOVFF  A4,11B
0B72:  CALL   010E
0B76:  MOVFF  03,8F
0B7A:  MOVFF  02,8E
0B7E:  MOVFF  01,8D
0B82:  MOVFF  00,8C
....................           
....................      if (uV2>max){ 
0B86:  MOVLB  1
0B88:  CLRF   x16
0B8A:  CLRF   x15
0B8C:  MOVLW  7A
0B8E:  MOVWF  x14
0B90:  MOVLW  88
0B92:  MOVWF  x13
0B94:  MOVFF  8F,11A
0B98:  MOVFF  8E,119
0B9C:  MOVFF  8D,118
0BA0:  MOVFF  8C,117
0BA4:  MOVLB  0
0BA6:  RCALL  05DA
0BA8:  BNC   0BB8
....................          uV2=max;} 
0BAA:  CLRF   x8F
0BAC:  CLRF   x8E
0BAE:  MOVLW  7A
0BB0:  MOVWF  x8D
0BB2:  MOVLW  88
0BB4:  MOVWF  x8C
0BB6:  BRA    0BE0
....................      else { 
....................          if (uV2<min){ 
0BB8:  MOVFF  8F,116
0BBC:  MOVFF  8E,115
0BC0:  MOVFF  8D,114
0BC4:  MOVFF  8C,113
0BC8:  MOVLB  1
0BCA:  CLRF   x1A
0BCC:  CLRF   x19
0BCE:  CLRF   x18
0BD0:  CLRF   x17
0BD2:  MOVLB  0
0BD4:  RCALL  05DA
0BD6:  BNC   0BE0
....................          uV2=min;} 
0BD8:  CLRF   x8F
0BDA:  CLRF   x8E
0BDC:  CLRF   x8D
0BDE:  CLRF   x8C
....................           } 
....................      control_M2 = uV2;  
0BE0:  MOVFF  8F,116
0BE4:  MOVFF  8E,115
0BE8:  MOVFF  8D,114
0BEC:  MOVFF  8C,113
0BF0:  RCALL  0654
0BF2:  MOVFF  02,4B
0BF6:  MOVFF  01,4A
....................      set_pwm1_duty(control_M1); //control_M1 
0BFA:  MOVFF  49,02
0BFE:  MOVFF  48,01
0C02:  RRCF   02,F
0C04:  RRCF   01,F
0C06:  RRCF   02,F
0C08:  RRCF   01,F
0C0A:  RRCF   02,F
0C0C:  MOVFF  01,FBE
0C10:  RRCF   02,F
0C12:  RRCF   02,W
0C14:  ANDLW  30
0C16:  MOVWF  00
0C18:  MOVF   FBD,W
0C1A:  ANDLW  CF
0C1C:  IORWF  00,W
0C1E:  MOVWF  FBD
....................      set_pwm2_duty(control_M2);//control_M2 
0C20:  MOVFF  4B,02
0C24:  MOVFF  4A,01
0C28:  RRCF   02,F
0C2A:  RRCF   01,F
0C2C:  RRCF   02,F
0C2E:  RRCF   01,F
0C30:  RRCF   02,F
0C32:  MOVFF  01,FBB
0C36:  RRCF   02,F
0C38:  RRCF   02,W
0C3A:  ANDLW  30
0C3C:  MOVWF  00
0C3E:  MOVF   FBA,W
0C40:  ANDLW  CF
0C42:  IORWF  00,W
0C44:  MOVWF  FBA
....................      iV0=iV; 
0C46:  MOVFF  77,87
0C4A:  MOVFF  76,86
0C4E:  MOVFF  75,85
0C52:  MOVFF  74,84
....................      eV0=eV; 
0C56:  MOVFF  73,8B
0C5A:  MOVFF  72,8A
0C5E:  MOVFF  71,89
0C62:  MOVFF  70,88
....................      iD0=iD; 
0C66:  MOVFF  97,9F
0C6A:  MOVFF  96,9E
0C6E:  MOVFF  95,9D
0C72:  MOVFF  94,9C
....................      eD0=eD; 
0C76:  MOVFF  93,A3
0C7A:  MOVFF  92,A2
0C7E:  MOVFF  91,A1
0C82:  MOVFF  90,A0
....................      //printf("\r\n M1= %Lu  M2= %Lu \r\n", control_M1, control_M2); 
....................       
....................      
.................... } 
....................  
....................  
.................... // INTERRUPCION por RECEPCION SERIE ------------------------------------------- 
....................  
0C86:  BCF    FA1.1
0C88:  GOTO   0084
.................... #int_rda 
.................... void serial_isr() { 
....................   if(kbhit()){ 
0C8C:  BTFSS  F9E.5
0C8E:  BRA    0C9E
....................     valor_pwm=4*getc(); 
0C90:  BTFSS  F9E.5
0C92:  BRA    0C90
0C94:  MOVF   FAE,W
0C96:  MULLW  04
0C98:  MOVF   FF3,W
0C9A:  CLRF   4D
0C9C:  MOVWF  4C
....................   } 
.................... } 
.................... // INTERRUPCION PARA SALIR DEL MODO SLEEP POR MEDIO DEL COMPARADOR------------ 
....................  
0C9E:  BCF    F9E.5
0CA0:  GOTO   0084
.................... #int_comp 
.................... void comp_isr(){ 
....................     
....................    counter_sleep=0; 
0CA4:  CLRF   5F
0CA6:  CLRF   5E
....................    wake_up=1; 
0CA8:  BSF    xD2.3
....................    temp=C1OUT; 
0CAA:  BCF    xD2.5
0CAC:  BTFSC  FB4.6
0CAE:  BSF    xD2.5
....................    temp=C2OUT; 
0CB0:  BCF    xD2.5
0CB2:  BTFSC  FB4.7
0CB4:  BSF    xD2.5
.................... } 
....................  
....................  
.................... // INTERRUPCION EXT por RB0 -------------------------------------------------- 
....................  
0CB6:  BCF    FA1.6
0CB8:  GOTO   0084
.................... #int_ext 
.................... void ext_isr() { 
....................  
....................   // Obtengo datos de Timer0 
....................    
....................   tt = get_timer0(); 
*
0CDC:  MOVF   FD6,W
0CDE:  MOVWF  xD6
0CE0:  MOVFF  FD7,D7
....................   t = tt-tti; 
0CE4:  MOVF   xD8,W
0CE6:  SUBWF  xD6,W
0CE8:  MOVWF  xDA
0CEA:  MOVF   xD9,W
0CEC:  SUBWFB xD7,W
0CEE:  MOVWF  xDB
....................   tti= tt; 
0CF0:  MOVFF  D7,D9
0CF4:  MOVFF  D6,D8
....................  
....................   if(start_recived==1){ 
0CF8:  BTFSS  xD2.1
0CFA:  BRA    0D86
....................     // Bit "0" 
....................     if(t>58 && t<68){ sbits[ntbits]='0';  
0CFC:  MOVF   xDB,F
0CFE:  BNZ   0D06
0D00:  MOVF   xDA,W
0D02:  SUBLW  3A
0D04:  BC    0D3C
0D06:  MOVF   xDB,F
0D08:  BNZ   0D3C
0D0A:  MOVF   xDA,W
0D0C:  SUBLW  43
0D0E:  BNC   0D3C
0D10:  CLRF   03
0D12:  MOVF   xDC,W
0D14:  ADDLW  C8
0D16:  MOVWF  FE9
0D18:  MOVLW  00
0D1A:  ADDWFC 03,W
0D1C:  MOVWF  FEA
0D1E:  MOVLW  30
0D20:  MOVWF  FEF
....................     times_cr[ntbits]=t; 
0D22:  BCF    FD8.0
0D24:  RLCF   xDC,W
0D26:  CLRF   03
0D28:  ADDLW  B4
0D2A:  MOVWF  FE9
0D2C:  MOVLW  00
0D2E:  ADDWFC 03,W
0D30:  MOVWF  FEA
0D32:  MOVFF  DB,FEC
0D36:  MOVF   FED,F
0D38:  MOVFF  DA,FEF
....................     } 
....................     // Bit "1" 
....................     if(t>90 && t<100){ sbits[ntbits]='1';  
0D3C:  MOVF   xDB,F
0D3E:  BNZ   0D46
0D40:  MOVF   xDA,W
0D42:  SUBLW  5A
0D44:  BC    0D7C
0D46:  MOVF   xDB,F
0D48:  BNZ   0D7C
0D4A:  MOVF   xDA,W
0D4C:  SUBLW  63
0D4E:  BNC   0D7C
0D50:  CLRF   03
0D52:  MOVF   xDC,W
0D54:  ADDLW  C8
0D56:  MOVWF  FE9
0D58:  MOVLW  00
0D5A:  ADDWFC 03,W
0D5C:  MOVWF  FEA
0D5E:  MOVLW  31
0D60:  MOVWF  FEF
....................     times_cr[ntbits]=t; 
0D62:  BCF    FD8.0
0D64:  RLCF   xDC,W
0D66:  CLRF   03
0D68:  ADDLW  B4
0D6A:  MOVWF  FE9
0D6C:  MOVLW  00
0D6E:  ADDWFC 03,W
0D70:  MOVWF  FEA
0D72:  MOVFF  DB,FEC
0D76:  MOVF   FED,F
0D78:  MOVFF  DA,FEF
....................     } 
....................     // Si he recibido 10 bits entonces hay dato 
....................     if(++ntbits==total_bits){ 
0D7C:  INCF   xDC,F
0D7E:  MOVF   xDC,W
0D80:  SUBLW  0A
0D82:  BNZ   0D86
....................       hay_dato=1; 
0D84:  BSF    xD2.2
....................     } 
....................   } 
....................  
....................   // Detecto Start Bit 
....................   if(t>153 && t<160){ 
0D86:  MOVF   xDB,F
0D88:  BNZ   0D90
0D8A:  MOVF   xDA,W
0D8C:  SUBLW  99
0D8E:  BC    0D9E
0D90:  MOVF   xDB,F
0D92:  BNZ   0D9E
0D94:  MOVF   xDA,W
0D96:  SUBLW  9F
0D98:  BNC   0D9E
....................     start_recived=1; 
0D9A:  BSF    xD2.1
....................     limpia_bits(); 
0D9C:  RCALL  0CBC
....................   } 
0D9E:  BCF    FF2.1
0DA0:  GOTO   0084
.................... } 
....................  
.................... //----------------------------------------------------------------------------- 
....................  
.................... void calculo_del_error(void){ 
....................       if ( mov_act == UP ){ 
....................          switch (mov_ant){ 
....................              
....................             case 0: 
....................             set_timer0(0); 
....................             set_timer1(0); 
....................             distancia_0 = mov_recto; 
....................             distancia_1 = mov_recto; 
....................             T0_Ant=0; 
....................             T0_Act=0; 
....................             T1_Ant=0; 
....................             T1_Act=0; 
....................             Delta_T0=0; 
....................             Delta_T1=0; 
....................             break; 
....................       
....................             case UP: 
....................             set_timer0(diferencia_T0); 
....................             set_timer1(diferencia_T1); 
....................             distancia_0 = mov_recto; 
....................             distancia_1 = mov_recto;  
....................             T0_Ant=diferencia_T0; 
....................             T0_Act=diferencia_T0; 
....................             T1_Ant=diferencia_T1; 
....................             T1_Act=diferencia_T1; 
....................             Delta_T0=0; 
....................             Delta_T1=0; 
....................             break; 
....................              
....................             case DOWN: 
....................             set_timer0(diferencia_T1); 
....................             set_timer1(diferencia_T0); 
....................             distancia_0 = mov_recto + diferencia_T1 + diferencia_T0 ; 
....................             distancia_1 = mov_recto + diferencia_T0 + diferencia_T1;  
....................             T0_Ant=diferencia_T1; 
....................             T0_Act=diferencia_T1; 
....................             T1_Ant=diferencia_T0; 
....................             T1_Act=diferencia_T0; 
....................             Delta_T0=0; 
....................             Delta_T1=0;          
....................             break; 
....................              
....................             case LEFT: 
....................             break; 
....................              
....................             case RIGHT: 
....................             break; 
....................             } 
....................       } 
....................       if ( mov_act == DOWN ){ 
....................          switch (mov_ant){ 
....................           
....................             case 0: 
....................             set_timer0(0); 
....................             set_timer1(0); 
....................             distancia_0 = mov_recto; 
....................             distancia_1 = mov_recto; 
....................             T0_Ant=0; 
....................             T0_Act=0; 
....................             T1_Ant=0; 
....................             T1_Act=0; 
....................             Delta_T0=0; 
....................             Delta_T1=0; 
....................             break; 
....................           
....................             case UP: 
....................             set_timer0(diferencia_T1); 
....................             set_timer1(diferencia_T0); 
....................             distancia_0 = mov_recto + diferencia_T1 + diferencia_T0 ; 
....................             distancia_1 = mov_recto + diferencia_T0 + diferencia_T1;  
....................             T0_Ant=diferencia_T1; 
....................             T0_Act=diferencia_T1; 
....................             T1_Ant=diferencia_T0; 
....................             T1_Act=diferencia_T0; 
....................             Delta_T0=0; 
....................             Delta_T1=0;             
....................             break; 
....................           
....................             case DOWN: 
....................             set_timer0(diferencia_T0); 
....................             set_timer1(diferencia_T1); 
....................             distancia_0 = mov_recto; 
....................             distancia_1 = mov_recto; 
....................             T0_Ant=diferencia_T0; 
....................             T0_Act=diferencia_T0; 
....................             T1_Ant=diferencia_T1; 
....................             T1_Act=diferencia_T1; 
....................             Delta_T0=0; 
....................             Delta_T1=0; 
....................             break; 
....................              
....................             case LEFT: 
....................             break; 
....................           
....................             case RIGHT: 
....................             break; 
....................             } 
....................       } 
....................       if ( mov_act == LEFT ){ 
....................          switch (mov_ant){ 
....................              
....................             case 0: 
....................             set_timer0(0); 
....................             set_timer1(0); 
....................             distancia_0 = mov_giro; 
....................             distancia_1 = mov_giro; 
....................             T0_Ant=0; 
....................             T0_Act=0; 
....................             T1_Ant=0; 
....................             T1_Act=0; 
....................             Delta_T0=0; 
....................             Delta_T1=0; 
....................             break; 
....................           
....................             case UP: 
....................             break; 
....................           
....................             case DOWN: 
....................             break; 
....................           
....................             case LEFT: 
....................             set_timer0(diferencia_T0); 
....................             set_timer1(diferencia_T1); 
....................             distancia_0 = mov_giro; 
....................             distancia_1 = mov_giro; 
....................             T0_Ant=diferencia_T0; 
....................             T0_Act=diferencia_T0; 
....................             T1_Ant=diferencia_T1; 
....................             T1_Act=diferencia_T1; 
....................             Delta_T0=0; 
....................             Delta_T1=0; 
....................             break; 
....................              
....................             case RIGHT: 
....................             set_timer0(0); 
....................             set_timer1(0); 
....................             distancia_0 = mov_giro + diferencia_T0; 
....................             distancia_1 = mov_giro + diferencia_T1; 
....................             T0_Ant=0; 
....................             T0_Act=0; 
....................             T1_Ant=0; 
....................             T1_Act=0; 
....................             Delta_T0=0; 
....................             Delta_T1=0; 
....................             break; 
....................             } 
....................       } 
....................       if ( mov_act == RIGHT ){ 
....................          switch (mov_ant){ 
....................           
....................             case 0: 
....................             set_timer0(0); 
....................             set_timer1(0); 
....................             distancia_0 = mov_giro; 
....................             distancia_1 = mov_giro; 
....................             T0_Ant=0; 
....................             T0_Act=0; 
....................             T1_Ant=0; 
....................             T1_Act=0; 
....................             Delta_T0=0; 
....................             Delta_T1=0; 
....................             break; 
....................           
....................             case UP: 
....................             break; 
....................           
....................             case DOWN: 
....................             break; 
....................           
....................             case LEFT: 
....................             set_timer0(0); 
....................             set_timer1(0); 
....................             distancia_0 = mov_giro + diferencia_T0; 
....................             distancia_1 = mov_giro + diferencia_T1; 
....................             T0_Ant=0; 
....................             T0_Act=0; 
....................             T1_Ant=0; 
....................             T1_Act=0; 
....................             Delta_T0=0; 
....................             Delta_T1=0; 
....................             break; 
....................           
....................             case RIGHT: 
....................             set_timer0(diferencia_T0); 
....................             set_timer1(diferencia_T1); 
....................             distancia_0 = mov_giro; 
....................             distancia_1 = mov_giro; 
....................             T0_Ant=diferencia_T0; 
....................             T0_Act=diferencia_T0; 
....................             T1_Ant=diferencia_T1; 
....................             T1_Act=diferencia_T1; 
....................             Delta_T0=0; 
....................             Delta_T1=0; 
....................             break; 
....................             } 
....................          }  
....................  } 
....................  
.................... void melodia_inicio(void){ 
....................    
....................   delay_ms(187); 
*
1268:  MOVLW  BB
126A:  MOVLB  1
126C:  MOVWF  x03
126E:  MOVLB  0
1270:  RCALL  0E5E
....................   generate_tone(391, 151); 
1272:  MOVLW  01
1274:  MOVWF  xED
1276:  MOVLW  87
1278:  MOVWF  xEC
127A:  CLRF   xEF
127C:  MOVLW  97
127E:  MOVWF  xEE
1280:  RCALL  1068
....................   delay_ms(35); 
1282:  MOVLW  23
1284:  MOVLB  1
1286:  MOVWF  x03
1288:  MOVLB  0
128A:  RCALL  0E5E
....................   generate_tone(391, 187); 
128C:  MOVLW  01
128E:  MOVWF  xED
1290:  MOVLW  87
1292:  MOVWF  xEC
1294:  CLRF   xEF
1296:  MOVLW  BB
1298:  MOVWF  xEE
129A:  RCALL  1068
....................   delay_ms(187); 
129C:  MOVLW  BB
129E:  MOVLB  1
12A0:  MOVWF  x03
12A2:  MOVLB  0
12A4:  RCALL  0E5E
....................   generate_tone(391, 187); 
12A6:  MOVLW  01
12A8:  MOVWF  xED
12AA:  MOVLW  87
12AC:  MOVWF  xEC
12AE:  CLRF   xEF
12B0:  MOVLW  BB
12B2:  MOVWF  xEE
12B4:  RCALL  1068
....................   generate_tone(440, 187); 
12B6:  MOVLW  01
12B8:  MOVWF  xED
12BA:  MOVLW  B8
12BC:  MOVWF  xEC
12BE:  CLRF   xEF
12C0:  MOVLW  BB
12C2:  MOVWF  xEE
12C4:  RCALL  1068
....................   delay_ms(187); 
12C6:  MOVLW  BB
12C8:  MOVLB  1
12CA:  MOVWF  x03
12CC:  MOVLB  0
12CE:  RCALL  0E5E
....................   generate_tone(466, 187); 
12D0:  MOVLW  01
12D2:  MOVWF  xED
12D4:  MOVLW  D2
12D6:  MOVWF  xEC
12D8:  CLRF   xEF
12DA:  MOVLW  BB
12DC:  MOVWF  xEE
12DE:  RCALL  1068
....................   delay_ms(187); 
12E0:  MOVLW  BB
12E2:  MOVLB  1
12E4:  MOVWF  x03
12E6:  MOVLB  0
12E8:  RCALL  0E5E
....................   generate_tone(493, 187); 
12EA:  MOVLW  01
12EC:  MOVWF  xED
12EE:  MOVLW  ED
12F0:  MOVWF  xEC
12F2:  CLRF   xEF
12F4:  MOVLW  BB
12F6:  MOVWF  xEE
12F8:  RCALL  1068
....................   delay_ms(562); 
12FA:  MOVLW  03
12FC:  MOVWF  xEC
12FE:  MOVLW  BB
1300:  MOVLB  1
1302:  MOVWF  x03
1304:  MOVLB  0
1306:  RCALL  0E5E
1308:  DECFSZ xEC,F
130A:  BRA    12FE
130C:  MOVLW  01
130E:  MOVLB  1
1310:  MOVWF  x03
1312:  MOVLB  0
1314:  RCALL  0E5E
....................   generate_tone(987, 187); 
1316:  MOVLW  03
1318:  MOVWF  xED
131A:  MOVLW  DB
131C:  MOVWF  xEC
131E:  CLRF   xEF
1320:  MOVLW  BB
1322:  MOVWF  xEE
1324:  RCALL  1068
1326:  GOTO   1B44 (RETURN)
.................... } 
....................  
.................... void melodia_sleep(void){ 
....................      
....................   delay_ms(187); 
*
1502:  MOVLW  BB
1504:  MOVLB  1
1506:  MOVWF  x03
1508:  MOVLB  0
150A:  RCALL  0E5E
....................   generate_tone(466, 187); 
150C:  MOVLW  01
150E:  MOVWF  xED
1510:  MOVLW  D2
1512:  MOVWF  xEC
1514:  CLRF   xEF
1516:  MOVLW  BB
1518:  MOVWF  xEE
151A:  RCALL  1068
....................   delay_ms(187); 
151C:  MOVLW  BB
151E:  MOVLB  1
1520:  MOVWF  x03
1522:  MOVLB  0
1524:  RCALL  0E5E
....................   generate_tone(493, 187); 
1526:  MOVLW  01
1528:  MOVWF  xED
152A:  MOVLW  ED
152C:  MOVWF  xEC
152E:  CLRF   xEF
1530:  MOVLW  BB
1532:  MOVWF  xEE
1534:  RCALL  1068
....................   delay_ms(562); 
1536:  MOVLW  03
1538:  MOVWF  xEC
153A:  MOVLW  BB
153C:  MOVLB  1
153E:  MOVWF  x03
1540:  MOVLB  0
1542:  RCALL  0E5E
1544:  DECFSZ xEC,F
1546:  BRA    153A
1548:  MOVLW  01
154A:  MOVLB  1
154C:  MOVWF  x03
154E:  MOVLB  0
1550:  RCALL  0E5E
....................   generate_tone(987, 187); 
1552:  MOVLW  03
1554:  MOVWF  xED
1556:  MOVLW  DB
1558:  MOVWF  xEC
155A:  CLRF   xEF
155C:  MOVLW  BB
155E:  MOVWF  xEE
1560:  RCALL  1068
1562:  GOTO   1CA8 (RETURN)
.................... } 
....................  
.................... Void melodia_wake_up(void){ 
....................      delay_ms(187); 
*
15F0:  MOVLW  BB
15F2:  MOVLB  1
15F4:  MOVWF  x03
15F6:  MOVLB  0
15F8:  RCALL  0E5E
....................      generate_tone(391, 151); 
15FA:  MOVLW  01
15FC:  MOVWF  xED
15FE:  MOVLW  87
1600:  MOVWF  xEC
1602:  CLRF   xEF
1604:  MOVLW  97
1606:  MOVWF  xEE
1608:  RCALL  1068
....................      delay_ms(35); 
160A:  MOVLW  23
160C:  MOVLB  1
160E:  MOVWF  x03
1610:  MOVLB  0
1612:  RCALL  0E5E
....................      generate_tone(391, 187); 
1614:  MOVLW  01
1616:  MOVWF  xED
1618:  MOVLW  87
161A:  MOVWF  xEC
161C:  CLRF   xEF
161E:  MOVLW  BB
1620:  MOVWF  xEE
1622:  RCALL  1068
....................      delay_ms(187); 
1624:  MOVLW  BB
1626:  MOVLB  1
1628:  MOVWF  x03
162A:  MOVLB  0
162C:  RCALL  0E5E
....................      generate_tone(391, 187); 
162E:  MOVLW  01
1630:  MOVWF  xED
1632:  MOVLW  87
1634:  MOVWF  xEC
1636:  CLRF   xEF
1638:  MOVLW  BB
163A:  MOVWF  xEE
163C:  RCALL  1068
....................      generate_tone(440, 187); 
163E:  MOVLW  01
1640:  MOVWF  xED
1642:  MOVLW  B8
1644:  MOVWF  xEC
1646:  CLRF   xEF
1648:  MOVLW  BB
164A:  MOVWF  xEE
164C:  RCALL  1068
....................      delay_ms(187); 
164E:  MOVLW  BB
1650:  MOVLB  1
1652:  MOVWF  x03
1654:  MOVLB  0
1656:  RCALL  0E5E
....................      setup_vref(VREF_HIGH | VREF_F5 | 8); 
1658:  MOVLW  C8
165A:  MOVWF  FB5
165C:  GOTO   1D30 (RETURN)
.................... } 
....................  
.................... void melodia_baja_bateria(void){ 
....................      generate_tone(391, 187); 
....................      delay_ms(187); 
....................      generate_tone(391, 187); 
....................      generate_tone(440, 187); 
....................      delay_ms(187); 
.................... } 
....................  
....................  
.................... Void verificar_level_ir(void){ 
....................  
....................      set_adc_channel(0); 
1660:  MOVLW  00
1662:  MOVWF  01
1664:  MOVF   FC2,W
1666:  ANDLW  C3
1668:  IORWF  01,W
166A:  MOVWF  FC2
....................      delay_us(20); 
166C:  MOVLW  21
166E:  MOVWF  00
1670:  DECFSZ 00,F
1672:  BRA    1670
....................      level_ir_b = read_adc(); 
1674:  BSF    FC2.1
1676:  BTFSC  FC2.1
1678:  BRA    1676
167A:  MOVFF  FC3,38
167E:  MOVFF  FC4,39
1682:  CLRF   19
1684:  BTFSC  FF2.7
1686:  BSF    19.7
1688:  BCF    FF2.7
....................      level_ir = (3.3 * level_ir_b / 1024.0); 
168A:  MOVFF  39,118
168E:  MOVFF  38,117
1692:  CALL   00D8
1696:  BTFSC  19.7
1698:  BSF    FF2.7
169A:  CLRF   19
169C:  BTFSC  FF2.7
169E:  BSF    19.7
16A0:  BCF    FF2.7
16A2:  MOVLW  33
16A4:  MOVLB  1
16A6:  MOVWF  x16
16A8:  MOVWF  x15
16AA:  MOVLW  53
16AC:  MOVWF  x14
16AE:  MOVLW  80
16B0:  MOVWF  x13
16B2:  MOVFF  03,11A
16B6:  MOVFF  02,119
16BA:  MOVFF  01,118
16BE:  MOVFF  00,117
16C2:  MOVLB  0
16C4:  CALL   04E4
16C8:  BTFSC  19.7
16CA:  BSF    FF2.7
16CC:  MOVFF  03,EF
16D0:  MOVFF  02,EE
16D4:  MOVFF  01,ED
16D8:  MOVFF  00,EC
16DC:  CLRF   19
16DE:  BTFSC  FF2.7
16E0:  BSF    19.7
16E2:  BCF    FF2.7
16E4:  MOVFF  03,11A
16E8:  MOVFF  02,119
16EC:  MOVFF  01,118
16F0:  MOVFF  00,117
16F4:  MOVLB  1
16F6:  CLRF   x1E
16F8:  CLRF   x1D
16FA:  CLRF   x1C
16FC:  MOVLW  89
16FE:  MOVWF  x1B
1700:  MOVLB  0
1702:  CALL   0386
1706:  BTFSC  19.7
1708:  BSF    FF2.7
170A:  MOVFF  03,67
170E:  MOVFF  02,66
1712:  MOVFF  01,65
1716:  MOVFF  00,64
171A:  CLRF   19
171C:  BTFSC  FF2.7
171E:  BSF    19.7
1720:  BCF    FF2.7
....................      if ( level_ir >= 2.8) 
1722:  MOVLW  33
1724:  MOVLB  1
1726:  MOVWF  x16
1728:  MOVWF  x15
172A:  MOVWF  x14
172C:  MOVLW  80
172E:  MOVWF  x13
1730:  MOVFF  67,11A
1734:  MOVFF  66,119
1738:  MOVFF  65,118
173C:  MOVFF  64,117
1740:  MOVLB  0
1742:  CALL   05DA
1746:  BTFSC  19.7
1748:  BSF    FF2.7
174A:  BC    174E
174C:  BNZ   1754
....................          vel_pwm = vel1; 
174E:  CLRF   4F
1750:  MOVLW  0A
1752:  MOVWF  4E
1754:  CLRF   19
1756:  BTFSC  FF2.7
1758:  BSF    19.7
175A:  BCF    FF2.7
....................      if ( level_ir >= 2.3 && level_ir <2.8) 
175C:  MOVLW  33
175E:  MOVLB  1
1760:  MOVWF  x16
1762:  MOVWF  x15
1764:  MOVLW  13
1766:  MOVWF  x14
1768:  MOVLW  80
176A:  MOVWF  x13
176C:  MOVFF  67,11A
1770:  MOVFF  66,119
1774:  MOVFF  65,118
1778:  MOVFF  64,117
177C:  MOVLB  0
177E:  CALL   05DA
1782:  BTFSC  19.7
1784:  BSF    FF2.7
1786:  BC    178A
1788:  BNZ   17C2
178A:  CLRF   19
178C:  BTFSC  FF2.7
178E:  BSF    19.7
1790:  BCF    FF2.7
1792:  MOVFF  67,116
1796:  MOVFF  66,115
179A:  MOVFF  65,114
179E:  MOVFF  64,113
17A2:  MOVLW  33
17A4:  MOVLB  1
17A6:  MOVWF  x1A
17A8:  MOVWF  x19
17AA:  MOVWF  x18
17AC:  MOVLW  80
17AE:  MOVWF  x17
17B0:  MOVLB  0
17B2:  CALL   05DA
17B6:  BTFSC  19.7
17B8:  BSF    FF2.7
17BA:  BNC   17C2
....................          vel_pwm = vel2; 
17BC:  CLRF   4F
17BE:  MOVLW  0F
17C0:  MOVWF  4E
17C2:  CLRF   19
17C4:  BTFSC  FF2.7
17C6:  BSF    19.7
17C8:  BCF    FF2.7
....................      if ( level_ir < 2.3) 
17CA:  MOVFF  67,116
17CE:  MOVFF  66,115
17D2:  MOVFF  65,114
17D6:  MOVFF  64,113
17DA:  MOVLW  33
17DC:  MOVLB  1
17DE:  MOVWF  x1A
17E0:  MOVWF  x19
17E2:  MOVLW  13
17E4:  MOVWF  x18
17E6:  MOVLW  80
17E8:  MOVWF  x17
17EA:  MOVLB  0
17EC:  CALL   05DA
17F0:  BTFSC  19.7
17F2:  BSF    FF2.7
17F4:  BNC   17FC
....................          vel_pwm = vel3; 
17F6:  CLRF   4F
17F8:  MOVLW  14
17FA:  MOVWF  4E
17FC:  GOTO   1982 (RETURN)
.................... } 
.................... Void level_source_ref(void){ 
....................  
....................      set_adc_channel(3); 
....................      delay_us(20); 
....................      level_source_b = read_adc(); 
....................      level_source = (3.3 * level_source_b / 1024.0)*2; 
....................      if (level_source <=4.5){ 
....................         melodia_baja_bateria(); 
....................         melodia_baja_bateria(); 
....................      } 
....................      //printf("\r\nVoltage = %01.2fV\r\n", level_source); 
.................... } 
.................... void ejecucion_pwm(void){ 
....................  
....................  
....................  
....................      setup_timer_2(t2_div_by_4, 255, 1);  //PR2=255, Tpwm=204,8 us F=4,8kHz 
1800:  MOVLW  00
1802:  IORLW  05
1804:  MOVWF  FCA
1806:  MOVLW  FF
1808:  MOVWF  FCB
....................      setup_timer_0(T0_EXT_L_TO_H | T0_DIV_1); 
180A:  MOVLW  A8
180C:  MOVWF  FD5
....................      setup_timer_1(T1_EXTERNAL_SYNC | T1_DIV_BY_1); 
180E:  MOVLW  83
1810:  MOVWF  FCD
....................      setup_timer_3(T3_INTERNAL | T3_DIV_BY_8); 
1812:  MOVLW  B5
1814:  MOVWF  FB1
....................      //calculo_del_error(); 
....................      set_timer0(0); 
1816:  CLRF   FD7
1818:  CLRF   FD6
....................      set_timer1(0); 
181A:  CLRF   FCF
181C:  CLRF   FCE
....................      set_timer3(34285); 
181E:  MOVLW  85
1820:  MOVWF  FB3
1822:  MOVLW  ED
1824:  MOVWF  FB2
....................      enable_interrupts(int_timer3); 
1826:  BSF    FA0.1
....................      disable_interrupts(int_rda); 
1828:  BCF    F9D.5
....................      disable_interrupts(int_ext); 
182A:  BCF    FF2.4
....................        
....................      eV=0; 
182C:  CLRF   73
182E:  CLRF   72
1830:  CLRF   71
1832:  CLRF   70
....................      iV=0; 
1834:  CLRF   77
1836:  CLRF   76
1838:  CLRF   75
183A:  CLRF   74
....................      dV=0; 
183C:  CLRF   7B
183E:  CLRF   7A
1840:  CLRF   79
1842:  CLRF   78
....................      uV=0; 
1844:  CLRF   x83
1846:  CLRF   x82
1848:  CLRF   x81
184A:  CLRF   x80
....................      uV2=0; 
184C:  CLRF   x8F
184E:  CLRF   x8E
1850:  CLRF   x8D
1852:  CLRF   x8C
....................      iV0=0; 
1854:  CLRF   x87
1856:  CLRF   x86
1858:  CLRF   x85
185A:  CLRF   x84
....................      eV0=0; 
185C:  CLRF   x8B
185E:  CLRF   x8A
1860:  CLRF   x89
1862:  CLRF   x88
....................      iD0=0; 
1864:  CLRF   x9F
1866:  CLRF   x9E
1868:  CLRF   x9D
186A:  CLRF   x9C
....................      eD0=0; 
186C:  CLRF   xA3
186E:  CLRF   xA2
1870:  CLRF   xA1
1872:  CLRF   xA0
....................      control_M1=0; 
1874:  CLRF   49
1876:  CLRF   48
....................      control_M2=0; 
1878:  CLRF   4B
187A:  CLRF   4A
....................      delta_recorrido=0; 
187C:  CLRF   xAF
187E:  CLRF   xAE
1880:  CLRF   xAD
1882:  CLRF   xAC
....................      T0_Ant = 0; 
1884:  CLRF   55
1886:  CLRF   54
....................      T1_Ant = 0; 
1888:  CLRF   57
188A:  CLRF   56
....................      T0_Act = 0; 
188C:  CLRF   51
188E:  CLRF   50
....................      T1_Act = 0; 
1890:  CLRF   53
1892:  CLRF   52
....................      Delta_T0 = 0; 
1894:  CLRF   59
1896:  CLRF   58
....................      Delta_T1 = 0; 
1898:  CLRF   5B
189A:  CLRF   5A
....................      set_pwm1_duty(control_M1); 
189C:  MOVFF  49,02
18A0:  MOVFF  48,01
18A4:  RRCF   02,F
18A6:  RRCF   01,F
18A8:  RRCF   02,F
18AA:  RRCF   01,F
18AC:  RRCF   02,F
18AE:  MOVFF  01,FBE
18B2:  RRCF   02,F
18B4:  RRCF   02,W
18B6:  ANDLW  30
18B8:  MOVWF  00
18BA:  MOVF   FBD,W
18BC:  ANDLW  CF
18BE:  IORWF  00,W
18C0:  MOVWF  FBD
....................      set_pwm2_duty(control_M2); 
18C2:  MOVFF  4B,02
18C6:  MOVFF  4A,01
18CA:  RRCF   02,F
18CC:  RRCF   01,F
18CE:  RRCF   02,F
18D0:  RRCF   01,F
18D2:  RRCF   02,F
18D4:  MOVFF  01,FBB
18D8:  RRCF   02,F
18DA:  RRCF   02,W
18DC:  ANDLW  30
18DE:  MOVWF  00
18E0:  MOVF   FBA,W
18E2:  ANDLW  CF
18E4:  IORWF  00,W
18E6:  MOVWF  FBA
....................      setup_ccp1(ccp_pwm);  
18E8:  BCF    F8B.2
18EA:  MOVLW  0C
18EC:  MOVWF  FBD
....................      setup_ccp2(ccp_pwm); 
18EE:  BCF    F8A.3
18F0:  MOVWF  FBA
....................      distancia_0=300; 
18F2:  MOVLW  01
18F4:  MOVWF  3D
18F6:  MOVLW  2C
18F8:  MOVWF  3C
....................      distancia_1=300; 
18FA:  MOVLW  01
18FC:  MOVWF  3F
18FE:  MOVLW  2C
1900:  MOVWF  3E
....................      enable_interrupts(global); 
1902:  MOVLW  C0
1904:  IORWF  FF2,F
....................       
....................      //for(i=0;i<11;++i){ 
....................      //valor_pwm=100*(int16)i; 
....................      //set_pwm1_duty(valor_pwm); 
....................      //set_pwm2_duty(valor_pwm); 
....................      //delay_ms(3000); 
....................      //} 
....................      //valor_pwm=500; 
....................      //set_pwm1_duty(valor_pwm); 
....................      //set_pwm2_duty(valor_pwm); 
....................      //delay_ms(10000); 
....................      //valor_pwm=600; 
....................      //set_pwm1_duty(valor_pwm); 
....................      //set_pwm2_duty(valor_pwm); 
....................      //delay_ms(10000); 
....................       
....................      if ( control_tipo ==1){ 
1906:  BTFSS  xD2.6
1908:  BRA    196A
....................          velocidad_ref = 10; 
190A:  CLRF   xAB
190C:  CLRF   xAA
190E:  MOVLW  20
1910:  MOVWF  xA9
1912:  MOVLW  82
1914:  MOVWF  xA8
....................          while ((get_timer0() <= distancia_0) | (get_timer1() <=distancia_1) ); 
1916:  MOVF   FD6,W
1918:  MOVFF  FD7,03
191C:  MOVWF  xEC
191E:  MOVF   FD7,W
1920:  MOVWF  xED
1922:  SUBWF  3D,W
1924:  BNC   192E
1926:  BNZ   1932
1928:  MOVF   xEC,W
192A:  SUBWF  3C,W
192C:  BC    1932
192E:  MOVLW  00
1930:  BRA    1934
1932:  MOVLW  01
1934:  MOVWF  xEC
1936:  MOVF   FCE,W
1938:  MOVFF  FCF,03
193C:  MOVWF  xED
193E:  MOVF   FCF,W
1940:  MOVWF  xEE
1942:  SUBWF  3F,W
1944:  BNC   194E
1946:  BNZ   1952
1948:  MOVF   xED,W
194A:  SUBWF  3E,W
194C:  BC    1952
194E:  MOVLW  00
1950:  BRA    1954
1952:  MOVLW  01
1954:  IORWF  xEC,W
1956:  BNZ   1916
....................          setup_ccp1(ccp_off); 
1958:  MOVLW  F0
195A:  ANDWF  FBD,F
....................          setup_ccp2(ccp_off); 
195C:  ANDWF  FBA,F
....................          output_low(PIN_B3); 
195E:  BCF    F8A.3
....................          output_low(PIN_C2); 
1960:  BCF    F8B.2
....................          output_B(input_b() & 0b00001111); 
1962:  MOVF   F81,W
1964:  ANDLW  0F
1966:  MOVWF  F8A
....................           
....................      } 
1968:  BRA    198C
....................      else { 
....................           
....................           
....................          //velocidad_ref = vel_pwm; 
....................          delay_ms(330); 
196A:  MOVLW  02
196C:  MOVWF  xEC
196E:  MOVLW  A5
1970:  MOVLB  1
1972:  MOVWF  x03
1974:  MOVLB  0
1976:  CALL   0E5E
197A:  DECFSZ xEC,F
197C:  BRA    196E
....................          disable_interrupts(int_timer3); 
197E:  BCF    FA0.1
....................          verificar_level_ir(); 
1980:  BRA    1660
....................          //if ( level_ir < 2.1){ 
....................             setup_ccp1(ccp_off); 
1982:  MOVLW  F0
1984:  ANDWF  FBD,F
....................             setup_ccp2(ccp_off); 
1986:  ANDWF  FBA,F
....................             output_low(PIN_C2); 
1988:  BCF    F8B.2
....................             output_low(PIN_B3); 
198A:  BCF    F8A.3
....................          //} 
....................          //else{ 
....................          //    setup_ccp1(ccp_off); 
....................          //    setup_ccp2(ccp_off); 
....................          //    output_low(PIN_B3); 
....................          //    output_low(PIN_C2); 
....................          //    output_B(input_b() & 0b00001111); 
....................          //} 
....................         
....................        //printf("\r\nV= %01.2fV\r\n", level_ir); 
....................      } 
....................       
....................      //delay_ms(1000); 
....................       
....................      //printf("\r\n\r Contador 0 = %5Lu y Contador 1 = %5Lu \r\n", get_timer0(), get_timer1()); 
....................      //level_source_ref(); 
....................      
....................       
....................      diferencia_T0 = get_timer0() - distancia_0; 
198C:  MOVF   FD6,W
198E:  MOVWF  xEC
1990:  MOVF   3C,W
1992:  SUBWF  xEC,W
1994:  MOVWF  40
1996:  MOVF   3D,W
1998:  SUBWFB FD7,W
199A:  MOVWF  41
....................      diferencia_T1 = get_timer1() - distancia_1; 
199C:  MOVF   FCE,W
199E:  MOVWF  xEC
19A0:  MOVF   3E,W
19A2:  SUBWF  xEC,W
19A4:  MOVWF  42
19A6:  MOVF   3F,W
19A8:  SUBWFB FCF,W
19AA:  MOVWF  43
....................      mov_ant = mov_act; 
19AC:  MOVFF  1B,1A
....................      setup_timer_1(T1_INTERNAL | T1_DIV_BY_1); 
19B0:  MOVLW  85
19B2:  MOVWF  FCD
....................      setup_timer_0(RTCC_INTERNAL | RTCC_DIV_128 ); 
19B4:  MOVLW  86
19B6:  MOVWF  FD5
....................      //enable_interrupts(int_rda); 
....................      enable_interrupts(int_ext); 
19B8:  BSF    FF2.4
....................      enable_interrupts(global); 
19BA:  MOVLW  C0
19BC:  IORWF  FF2,F
19BE:  RETURN 0
.................... }   
....................  
.................... void convierte_bits_a_bytes(void){ 
....................  
....................   for(i=0;i<2;++i){ 
*
1566:  CLRF   xD3
1568:  MOVF   xD3,W
156A:  SUBLW  01
156C:  BNC   15E6
....................     Bytes[i]=0x00; 
156E:  CLRF   03
1570:  MOVF   xD3,W
1572:  ADDLW  E6
1574:  MOVWF  FE9
1576:  MOVLW  00
1578:  ADDWFC 03,W
157A:  MOVWF  FEA
157C:  CLRF   FEF
....................     for(j=0;j<5;++j){ 
157E:  CLRF   xD4
1580:  MOVF   xD4,W
1582:  SUBLW  04
1584:  BNC   15E2
....................       if(sbits[(i*5)+j]=='1'){ 
1586:  MOVF   xD3,W
1588:  MULLW  05
158A:  MOVF   FF3,W
158C:  ADDWF  xD4,W
158E:  CLRF   03
1590:  ADDLW  C8
1592:  MOVWF  FE9
1594:  MOVLW  00
1596:  ADDWFC 03,W
1598:  MOVWF  FEA
159A:  MOVF   FEF,W
159C:  SUBLW  31
159E:  BNZ   15DE
....................         bytes[i]=bytes[i]|Bits[j]; 
15A0:  CLRF   03
15A2:  MOVF   xD3,W
15A4:  ADDLW  E6
15A6:  MOVWF  01
15A8:  MOVLW  00
15AA:  ADDWFC 03,F
15AC:  MOVFF  03,ED
15B0:  CLRF   03
15B2:  MOVF   xD3,W
15B4:  ADDLW  E6
15B6:  MOVWF  FE9
15B8:  MOVLW  00
15BA:  ADDWFC 03,W
15BC:  MOVWF  FEA
15BE:  MOVFF  FEF,EE
15C2:  CLRF   03
15C4:  MOVF   xD4,W
15C6:  ADDLW  DE
15C8:  MOVWF  FE9
15CA:  MOVLW  00
15CC:  ADDWFC 03,W
15CE:  MOVWF  FEA
15D0:  MOVF   FEF,W
15D2:  IORWF  xEE,W
15D4:  MOVFF  ED,FEA
15D8:  MOVFF  01,FE9
15DC:  MOVWF  FEF
....................       } 
15DE:  INCF   xD4,F
15E0:  BRA    1580
....................     } 
15E2:  INCF   xD3,F
15E4:  BRA    1568
....................   } 
....................   dato_ir=bytes[0]; 
15E6:  MOVFF  E6,E9
....................   identificador=bytes[1]; 
15EA:  MOVFF  E7,E8
15EE:  RETURN 0
.................... } 
....................  
.................... void muestra_bits(void){ 
....................  
....................   printf("\r\n\PULSO RECIBIDO -----------------------\r\n"); 
....................  
....................   for(i=0;i<2;++i){ 
....................     printf("Byte %u = \r",i+1); 
....................     for(k=0;k<2;++k){ 
....................       //if(k==1){ 
....................       //  printf(" %u ", i+1); 
....................       //} 
....................       for(j=0;j<5;++j){ 
....................         switch(k){ 
....................           case 0: printf("%2u ",6-((i*-5)+j+1)); 
....................                   break; 
....................           case 1: printf("%2c ",sbits[4-((i*-5)+j)]); 
....................                   break; 
....................         } 
....................       } 
....................       if(k==0){ printf("\r\n"); } 
....................     } 
....................     printf(" Valor = %u\r\n",Bytes[i]); 
....................   } 
....................   printf("Address = %u Command = %u\r\n",Bytes[1],Bytes[0]); 
....................   ntbits=0; 
....................   printf("Byte = \r"); 
....................   for(i=0;i<10;++i){ 
....................   printf("%2Lu \r",times_cr[i]); 
....................   } 
....................  
.................... } 
....................  
.................... void main() { 
*
19C0:  CLRF   FF8
19C2:  BCF    FD0.7
19C4:  BSF    07.7
19C6:  BSF    FB8.3
19C8:  MOVLW  56
19CA:  MOVWF  FAF
19CC:  MOVLW  00
19CE:  MOVWF  FB0
19D0:  MOVLW  A6
19D2:  MOVWF  FAC
19D4:  MOVLW  90
19D6:  MOVWF  FAB
19D8:  NOP   
19DA:  NOP   
19DC:  CLRF   1A
19DE:  CLRF   1B
19E0:  CLRF   45
19E2:  CLRF   44
19E4:  CLRF   47
19E6:  CLRF   46
19E8:  CLRF   4D
19EA:  CLRF   4C
19EC:  CLRF   4F
19EE:  CLRF   4E
19F0:  CLRF   51
19F2:  CLRF   50
19F4:  CLRF   53
19F6:  CLRF   52
19F8:  CLRF   55
19FA:  CLRF   54
19FC:  CLRF   57
19FE:  CLRF   56
1A00:  CLRF   59
1A02:  CLRF   58
1A04:  CLRF   5B
1A06:  CLRF   5A
1A08:  CLRF   5D
1A0A:  CLRF   5C
1A0C:  CLRF   5F
1A0E:  CLRF   5E
1A10:  CLRF   xAB
1A12:  CLRF   xAA
1A14:  CLRF   xA9
1A16:  CLRF   xA8
1A18:  CLRF   xAF
1A1A:  CLRF   xAE
1A1C:  CLRF   xAD
1A1E:  CLRF   xAC
1A20:  CLRF   xB3
1A22:  CLRF   xB2
1A24:  CLRF   xB1
1A26:  CLRF   xB0
1A28:  BCF    xD2.0
1A2A:  BCF    xD2.1
1A2C:  CLRF   xDC
1A2E:  BCF    xD2.2
1A30:  CLRF   xDD
1A32:  MOVLW  01
1A34:  MOVWF  xE8
1A36:  CLRF   xE9
1A38:  BCF    xD2.3
1A3A:  BCF    xD2.4
1A3C:  CLRF   xEB
1A3E:  CLRF   xEA
1A40:  MOVF   FC1,W
1A42:  ANDLW  C0
1A44:  IORLW  0F
1A46:  MOVWF  FC1
1A48:  MOVLW  07
1A4A:  MOVWF  FB4
1A4C:  CLRF   1C
1A4E:  CLRF   1D
1A50:  CLRF   xB4
1A52:  CLRF   xB5
1A54:  MOVLW  01
1A56:  MOVWF  xDE
1A58:  MOVLW  02
1A5A:  MOVWF  xDF
1A5C:  MOVLW  04
1A5E:  MOVWF  xE0
1A60:  MOVLW  08
1A62:  MOVWF  xE1
1A64:  MOVLW  10
1A66:  MOVWF  xE2
1A68:  MOVLW  20
1A6A:  MOVWF  xE3
1A6C:  MOVLW  40
1A6E:  MOVWF  xE4
1A70:  MOVLW  80
1A72:  MOVWF  xE5
1A74:  CLRF   xE6
1A76:  CLRF   xE7
....................    
....................   disable_interrupts(global); 
1A78:  BCF    FF2.6
1A7A:  BCF    FF2.7
1A7C:  BTFSC  FF2.7
1A7E:  BRA    1A7A
....................   setup_adc_ports(AN0_TO_AN3 | VSS_VDD); 
1A80:  MOVF   FC1,W
1A82:  ANDLW  C0
1A84:  IORLW  0B
1A86:  MOVWF  FC1
....................   setup_adc(ADC_CLOCK_DIV_32); 
1A88:  MOVF   FC0,W
1A8A:  ANDLW  C0
1A8C:  IORLW  02
1A8E:  MOVWF  FC0
1A90:  BSF    FC0.7
1A92:  BSF    FC2.0
....................   setup_spi(FALSE); 
1A94:  CLRF   FC6
....................   //setup_counters(RTCC_INTERNAL,RTCC_DIV_2); 
....................   setup_WDT(WDT_OFF); 
1A96:  BCF    FD1.0
....................   setup_timer_1(T1_INTERNAL | T1_DIV_BY_1); 
1A98:  MOVLW  85
1A9A:  MOVWF  FCD
....................   setup_timer_2(T2_DISABLED,0,1); 
1A9C:  MOVLW  00
1A9E:  MOVWF  FCA
1AA0:  MOVLW  00
1AA2:  MOVWF  FCB
....................   setup_timer_3(T3_DISABLED); 
1AA4:  CLRF   FB1
....................   setup_comparator(NC_NC_NC_NC); 
1AA6:  MOVLW  07
1AA8:  MOVWF  FB4
1AAA:  MOVF   F92,W
1AAC:  MOVWF  F92
1AAE:  MOVLW  10
1AB0:  MOVWF  00
1AB2:  DECFSZ 00,F
1AB4:  BRA    1AB2
1AB6:  NOP   
1AB8:  MOVF   FB4,W
1ABA:  BCF    FA1.6
....................   setup_vref(VREF_HIGH | VREF_F5 | 8); 
1ABC:  MOVLW  C8
1ABE:  MOVWF  FB5
....................   port_b_pullups(FALSE); 
1AC0:  BSF    FF1.7
....................     
....................   setup_timer_0(T0_INTERNAL | T0_DIV_128 ); 
1AC2:  MOVLW  86
1AC4:  MOVWF  FD5
....................   set_tris_a(0b00011011);  
1AC6:  MOVLW  1B
1AC8:  MOVWF  F92
....................   set_tris_b(0b00000001); 
1ACA:  MOVLW  01
1ACC:  MOVWF  F93
....................   set_tris_c(0b10000001); 
1ACE:  MOVLW  81
1AD0:  MOVWF  F94
....................   output_a(0x00); 
1AD2:  CLRF   F89
....................   output_b(0x00); 
1AD4:  CLRF   F8A
....................   output_c(0x00); 
1AD6:  CLRF   F8B
....................   delay_ms(500); 
1AD8:  MOVLW  02
1ADA:  MOVWF  xEC
1ADC:  MOVLW  FA
1ADE:  MOVLB  1
1AE0:  MOVWF  x03
1AE2:  MOVLB  0
1AE4:  CALL   0E5E
1AE8:  DECFSZ xEC,F
1AEA:  BRA    1ADC
....................     
....................   printf("\r\n"); 
1AEC:  MOVLW  0D
1AEE:  BTFSS  F9E.4
1AF0:  BRA    1AEE
1AF2:  MOVWF  FAD
1AF4:  MOVLW  0A
1AF6:  BTFSS  F9E.4
1AF8:  BRA    1AF6
1AFA:  MOVWF  FAD
....................   printf("Hola Soy el Robot CUICUI 2.0 :D %s\r\n",version); 
1AFC:  MOVLW  10
1AFE:  MOVWF  FF6
1B00:  MOVLW  0E
1B02:  MOVWF  FF7
1B04:  MOVLW  20
1B06:  MOVWF  xEC
1B08:  CALL   0E86
1B0C:  MOVLW  D2
1B0E:  MOVWF  FF6
1B10:  MOVLW  00
1B12:  MOVWF  FF7
1B14:  CALL   0EA6
1B18:  MOVLW  0D
1B1A:  BTFSS  F9E.4
1B1C:  BRA    1B1A
1B1E:  MOVWF  FAD
1B20:  MOVLW  0A
1B22:  BTFSS  F9E.4
1B24:  BRA    1B22
1B26:  MOVWF  FAD
....................   
....................   
....................   ext_int_edge(H_TO_L);      //Interrupcin de high a Low 
1B28:  BCF    FF1.6
....................   first_ext=0; 
1B2A:  BCF    xD2.0
....................   start_recived=0; 
1B2C:  BCF    xD2.1
....................   hay_dato=0; 
1B2E:  BCF    xD2.2
1B30:  CLRF   19
1B32:  BTFSC  FF2.7
1B34:  BSF    19.7
1B36:  BCF    FF2.7
....................  
....................   limpia_bits(); 
1B38:  CALL   0CBC
1B3C:  BTFSC  19.7
1B3E:  BSF    FF2.7
....................                             //Meloda de Inicio 
....................   melodia_inicio(); 
1B40:  GOTO   1268
....................   //Recibo de un dato por arduino 
....................   /* 
....................   while(True){ 
....................    valorR = kbhit(); 
....................    if(ValorR == 1){ 
....................       melodia_inicio(); 
....................       valorR=0; 
....................    } 
....................   }*/ 
....................    
....................   disable_interrupts(int_timer3); 
1B44:  BCF    FA0.1
....................   setup_timer_3(T3_INTERNAL | T3_DIV_BY_8); 
1B46:  MOVLW  B5
1B48:  MOVWF  FB1
....................   set_timer3(0); 
1B4A:  CLRF   FB3
1B4C:  CLRF   FB2
....................    
....................   disable_interrupts(int_rda); 
1B4E:  BCF    F9D.5
....................   enable_interrupts(int_ext); 
1B50:  BSF    FF2.4
....................    
....................   set_adc_channel(3); 
1B52:  MOVLW  0C
1B54:  MOVWF  01
1B56:  MOVF   FC2,W
1B58:  ANDLW  C3
1B5A:  IORWF  01,W
1B5C:  MOVWF  FC2
....................   delay_us(20); 
1B5E:  MOVLW  21
1B60:  MOVWF  00
1B62:  DECFSZ 00,F
1B64:  BRA    1B62
....................   level_source_b = read_adc(); 
1B66:  BSF    FC2.1
1B68:  BTFSC  FC2.1
1B6A:  BRA    1B68
1B6C:  MOVFF  FC3,3A
1B70:  MOVFF  FC4,3B
1B74:  CLRF   19
1B76:  BTFSC  FF2.7
1B78:  BSF    19.7
1B7A:  BCF    FF2.7
....................   level_source = 2*(3.3 * level_source_b / 1024); 
1B7C:  MOVFF  3B,118
1B80:  MOVFF  3A,117
1B84:  CALL   00D8
1B88:  BTFSC  19.7
1B8A:  BSF    FF2.7
1B8C:  CLRF   19
1B8E:  BTFSC  FF2.7
1B90:  BSF    19.7
1B92:  BCF    FF2.7
1B94:  MOVLW  33
1B96:  MOVLB  1
1B98:  MOVWF  x16
1B9A:  MOVWF  x15
1B9C:  MOVLW  53
1B9E:  MOVWF  x14
1BA0:  MOVLW  80
1BA2:  MOVWF  x13
1BA4:  MOVFF  03,11A
1BA8:  MOVFF  02,119
1BAC:  MOVFF  01,118
1BB0:  MOVFF  00,117
1BB4:  MOVLB  0
1BB6:  CALL   04E4
1BBA:  BTFSC  19.7
1BBC:  BSF    FF2.7
1BBE:  MOVFF  03,EF
1BC2:  MOVFF  02,EE
1BC6:  MOVFF  01,ED
1BCA:  MOVFF  00,EC
1BCE:  CLRF   19
1BD0:  BTFSC  FF2.7
1BD2:  BSF    19.7
1BD4:  BCF    FF2.7
1BD6:  MOVFF  03,11A
1BDA:  MOVFF  02,119
1BDE:  MOVFF  01,118
1BE2:  MOVFF  00,117
1BE6:  MOVLB  1
1BE8:  CLRF   x1E
1BEA:  CLRF   x1D
1BEC:  CLRF   x1C
1BEE:  MOVLW  89
1BF0:  MOVWF  x1B
1BF2:  MOVLB  0
1BF4:  CALL   0386
1BF8:  BTFSC  19.7
1BFA:  BSF    FF2.7
1BFC:  CLRF   19
1BFE:  BTFSC  FF2.7
1C00:  BSF    19.7
1C02:  BCF    FF2.7
1C04:  MOVLB  1
1C06:  CLRF   x16
1C08:  CLRF   x15
1C0A:  CLRF   x14
1C0C:  MOVLW  80
1C0E:  MOVWF  x13
1C10:  MOVFF  03,11A
1C14:  MOVFF  02,119
1C18:  MOVFF  01,118
1C1C:  MOVFF  00,117
1C20:  MOVLB  0
1C22:  CALL   04E4
1C26:  BTFSC  19.7
1C28:  BSF    FF2.7
1C2A:  MOVFF  03,6B
1C2E:  MOVFF  02,6A
1C32:  MOVFF  01,69
1C36:  MOVFF  00,68
....................      //if (level_source <=4.5){ 
....................      //   melodia_baja_bateria(); 
....................      //   melodia_baja_bateria(); 
....................      //} 
....................      printf("\r\nVoltage = %01.2fV\r\n", level_source); 
1C3A:  MOVLW  36
1C3C:  MOVWF  FF6
1C3E:  MOVLW  0E
1C40:  MOVWF  FF7
1C42:  MOVLW  0C
1C44:  MOVWF  xEC
1C46:  CALL   0E86
1C4A:  MOVLW  C9
1C4C:  MOVWF  FE9
1C4E:  MOVFF  6B,EF
1C52:  MOVFF  6A,EE
1C56:  MOVFF  69,ED
1C5A:  MOVFF  68,EC
1C5E:  MOVLW  02
1C60:  MOVWF  xF0
1C62:  GOTO   136A
1C66:  MOVLW  48
1C68:  MOVWF  FF6
1C6A:  MOVLW  0E
1C6C:  MOVWF  FF7
1C6E:  MOVLW  03
1C70:  MOVWF  xEC
1C72:  CALL   0E86
....................    
....................    
....................    
....................    
....................   enable_interrupts(global); 
1C76:  MOVLW  C0
1C78:  IORWF  FF2,F
....................   TMR3IF = 0; 
1C7A:  BCF    FA1.1
....................   counter_sleep = 0; 
1C7C:  CLRF   5F
1C7E:  CLRF   5E
....................    
....................    
....................    
....................    
....................   do { 
....................      if( TMR3IF == 1){ 
1C80:  BTFSS  FA1.1
1C82:  BRA    1D32
....................          TMR3IF = 0; 
1C84:  BCF    FA1.1
....................          counter_sleep = counter_sleep + 1; 
1C86:  MOVLW  01
1C88:  ADDWF  5E,F
1C8A:  MOVLW  00
1C8C:  ADDWFC 5F,F
....................                      if ( counter_sleep >= 286){        //Tiempo estimado 2 min ==>1145...30s =286 
1C8E:  MOVF   5F,W
1C90:  SUBLW  00
1C92:  BC    1D32
1C94:  XORLW  FF
1C96:  BNZ   1C9E
1C98:  MOVF   5E,W
1C9A:  SUBLW  1D
1C9C:  BC    1D32
....................                           disable_interrupts(global); 
1C9E:  BCF    FF2.6
1CA0:  BCF    FF2.7
1CA2:  BTFSC  FF2.7
1CA4:  BRA    1CA0
....................                           melodia_sleep(); 
1CA6:  BRA    1502
....................                           setup_vref( VREF_HIGH | 15);    //Tension de referencia Vref=2,475 para Vcc = 3,3 V y Vref=3,06 para Vcc = 5,16 V 
1CA8:  MOVLW  8F
1CAA:  MOVWF  FB5
....................                           setup_comparator(A0_VR_A1_VR); 
1CAC:  MOVLW  06
1CAE:  MOVWF  FB4
1CB0:  MOVF   F92,W
1CB2:  IORLW  03
1CB4:  MOVWF  F92
1CB6:  MOVLW  10
1CB8:  MOVWF  00
1CBA:  DECFSZ 00,F
1CBC:  BRA    1CBA
1CBE:  NOP   
1CC0:  MOVF   FB4,W
1CC2:  BCF    FA1.6
....................                           disable_interrupts(int_ext); 
1CC4:  BCF    FF2.4
....................                           enable_interrupts(INT_COMP); 
1CC6:  BSF    FA0.6
....................                           enable_interrupts(global); 
1CC8:  MOVLW  C0
1CCA:  IORWF  FF2,F
....................                            
....................                           while ( out_sleep == 0){ 
1CCC:  BTFSC  xD2.4
1CCE:  BRA    1D0E
....................                                 sleep(); 
1CD0:  MOVFF  FD3,00
1CD4:  BCF    FD3.7
1CD6:  SLEEP 
1CD8:  MOVFF  00,FD3
....................                                 delay_cycles(1); 
1CDC:  NOP   
....................                                 disable_interrupts(INT_COMP); 
1CDE:  BCF    FA0.6
....................                                 delay_us(100); 
1CE0:  MOVLW  A6
1CE2:  MOVWF  00
1CE4:  DECFSZ 00,F
1CE6:  BRA    1CE4
1CE8:  NOP   
....................                                 //printf("\r\nDespierta para verificar\r\n"); 
....................                                 enable_interrupts(int_ext); 
1CEA:  BSF    FF2.4
....................                                 while ( hay_dato == 0 ); 
1CEC:  BTFSS  xD2.2
1CEE:  BRA    1CEC
....................                                 
....................                                 convierte_bits_a_bytes(); 
1CF0:  RCALL  1566
....................                                 if (bytes[1]== 7 && wake_up == 1){ 
1CF2:  MOVF   xE7,W
1CF4:  SUBLW  07
1CF6:  BNZ   1D02
1CF8:  BTFSS  xD2.3
1CFA:  BRA    1D02
....................                                 out_sleep=1; 
1CFC:  BSF    xD2.4
....................                                 disable_interrupts(int_ext); 
1CFE:  BCF    FF2.4
....................                                 //printf("\r\nDespierto...era para mi\r\n"); 
....................                                 } 
1D00:  BRA    1D0A
....................                                 else{ 
....................                                 disable_interrupts(int_ext); 
1D02:  BCF    FF2.4
....................                                 enable_interrupts(INT_COMP); 
1D04:  BSF    FA0.6
....................                                 wake_up = 0; 
1D06:  BCF    xD2.3
....................                                 out_sleep = 0; 
1D08:  BCF    xD2.4
....................                                 //printf("\r\nMe voi a Dormir\r\n"); 
....................                                 } 
....................                                 hay_dato=0; 
1D0A:  BCF    xD2.2
1D0C:  BRA    1CCC
....................                           } 
....................                            
....................                           hay_dato = 0; 
1D0E:  BCF    xD2.2
....................                           wake_up = 0; 
1D10:  BCF    xD2.3
....................                           out_sleep = 0; 
1D12:  BCF    xD2.4
....................                           disable_interrupts(INT_COMP); 
1D14:  BCF    FA0.6
....................                           setup_vref(false); 
1D16:  CLRF   FB5
....................                           setup_comparator(NC_NC_NC_NC); 
1D18:  MOVLW  07
1D1A:  MOVWF  FB4
1D1C:  MOVF   F92,W
1D1E:  MOVWF  F92
1D20:  MOVLW  10
1D22:  MOVWF  00
1D24:  DECFSZ 00,F
1D26:  BRA    1D24
1D28:  NOP   
1D2A:  MOVF   FB4,W
1D2C:  BCF    FA1.6
....................                           melodia_wake_up(); 
1D2E:  BRA    15F0
....................                           enable_interrupts(int_ext); 
1D30:  BSF    FF2.4
....................                      }                     
....................      } 
....................  
....................  
....................  
....................     if(hay_dato==1){ 
1D32:  BTFSS  xD2.2
1D34:  BRA    20BE
....................        counter_sleep=0; 
1D36:  CLRF   5F
1D38:  CLRF   5E
....................        disable_interrupts(global); 
1D3A:  BCF    FF2.6
1D3C:  BCF    FF2.7
1D3E:  BTFSC  FF2.7
1D40:  BRA    1D3C
....................        hay_dato=0; 
1D42:  BCF    xD2.2
....................        convierte_bits_a_bytes(); 
1D44:  RCALL  1566
....................        //muestra_bits(); 
....................        //set_adc_channel(3); 
....................        //delay_us(20); 
....................        //q = read_adc(); 
....................        //p = (3.3 * q / 1024.0)*2; 
....................        //printf("\r\nVoltage = %01.2fV\r\n", p); 
....................                
....................         
....................        if (bytes[1] == 7){ 
1D46:  MOVF   xE7,W
1D48:  SUBLW  07
1D4A:  BTFSS  FD8.2
1D4C:  BRA    20AA
....................        if (bit_test(bytes[0],4) == 0){ 
1D4E:  BTFSC  xE6.4
1D50:  BRA    1E4A
....................                                                                                 //Verificar tensin  
....................         
....................         
....................             switch (bytes[0]){ 
1D52:  MOVLW  02
1D54:  SUBWF  xE6,W
1D56:  ADDLW  F9
1D58:  BTFSC  FD8.0
1D5A:  BRA    1E48
1D5C:  ADDLW  07
1D5E:  GOTO   20C2
....................             case UP : 
....................                  //printf("Robot Avanza \r"); 
....................                  //output_B((input_b() & 0b00001111) | 0b01100000 );  
....................                  //ejecucion_pwm(); 
....................                  //verificar_level_ir(); 
....................                  control_tipo=0; 
1D62:  BCF    xD2.6
....................                  output_B((input_b() & 0b00001111) | 0b01100000 ); //(M2B, M2A, M1B, M1A, PWM2, RB2, RB1, IRDATA)                  
1D64:  MOVF   F81,W
1D66:  ANDLW  0F
1D68:  IORLW  60
1D6A:  MOVWF  F8A
....................                  vel_pwm = vel3; 
1D6C:  CLRF   4F
1D6E:  MOVLW  14
1D70:  MOVWF  4E
....................                  output_high(PIN_B1); 
1D72:  BSF    F8A.1
....................                   
....................                  ejecucion_pwm(); 
1D74:  RCALL  1800
....................                  output_low(PIN_B1); 
1D76:  BCF    F8A.1
....................                  //setup_timer_2(t2_div_by_1, 224, 1);  //PR2=224, Tpwm=225 us F= 4.4kHz 
....................                  //set_pwm1_duty(vel_pwm); 
....................                  //set_pwm2_duty(vel_pwm); 
....................                  //setup_ccp1(ccp_pwm); 
....................                  //setup_ccp2(ccp_pwm); 
....................                  //delay_ms(400); 
....................                  //setup_ccp1(ccp_off); 
....................                  //setup_ccp2(ccp_off); 
....................                  //output_low(PIN_C2); 
....................                  //output_low(PIN_B3); 
....................                  //output_B((input_b() & 0b00001111)); 
....................                   
....................                  break; 
1D78:  BRA    1E48
....................             case DOWN : 
....................                  //printf("Robot Retrocede \r"); 
....................                  //verificar_level_ir(); 
....................                  control_tipo=0; 
1D7A:  BCF    xD2.6
....................                  output_B((input_b() & 0b00001111) | 0b10010000 ); //(M2B, M2A, M1B, M1A, PWM2, RB2, RB1, IRDATA)     
1D7C:  MOVF   F81,W
1D7E:  ANDLW  0F
1D80:  IORLW  90
1D82:  MOVWF  F8A
....................                  vel_pwm = vel3; 
1D84:  CLRF   4F
1D86:  MOVLW  14
1D88:  MOVWF  4E
....................                  output_high(PIN_B1); 
1D8A:  BSF    F8A.1
....................                  ejecucion_pwm(); 
1D8C:  RCALL  1800
....................                  output_low(PIN_B1); 
1D8E:  BCF    F8A.1
....................                 //setup_timer_2(t2_div_by_1, 224, 1);  //PR2=224, Tpwm=225 us 
....................                  //set_pwm1_duty(vel_pwm); 
....................                  //set_pwm2_duty(vel_pwm); 
....................                  //setup_ccp1(ccp_pwm); 
....................                  //setup_ccp2(ccp_pwm); 
....................                  //delay_ms(400); 
....................                  //setup_ccp1(ccp_off); 
....................                  //setup_ccp2(ccp_off); 
....................                  //output_low(PIN_C2); 
....................                  //output_low(PIN_B3); 
....................                  //output_B((input_b() & 0b00001111));           
....................                   
....................                  break; 
1D90:  BRA    1E48
....................             case LEFT : 
....................                  //printf("Robot Gira a la Izquierda \r"); 
....................                  //verificar_level_ir(); 
....................                   
....................                  control_tipo=0; 
1D92:  BCF    xD2.6
....................                  output_B((input_b() & 0b00001111) | 0b10100000 ); //(M2B, M2A, M1B, M1A, PWM2, RB2, RB1, IRDATA)                  
1D94:  MOVF   F81,W
1D96:  ANDLW  0F
1D98:  IORLW  A0
1D9A:  MOVWF  F8A
....................                  vel_pwm = vel3; 
1D9C:  CLRF   4F
1D9E:  MOVLW  14
1DA0:  MOVWF  4E
....................                  output_high(PIN_B1); 
1DA2:  BSF    F8A.1
....................                  ejecucion_pwm(); 
1DA4:  RCALL  1800
....................                  output_low(PIN_B1); 
1DA6:  BCF    F8A.1
....................                  //setup_timer_2(t2_div_by_1, 224, 1);  //PR2=224, Tpwm=225 us 
....................                  //set_pwm1_duty(vel_pwm); 
....................                  //set_pwm2_duty(vel_pwm); 
....................                  //setup_ccp1(ccp_pwm); 
....................                  //setup_ccp2(ccp_pwm); 
....................                  //delay_ms(400); 
....................                  //setup_ccp1(ccp_off); 
....................                  //setup_ccp2(ccp_off); 
....................                  //output_low(PIN_C2); 
....................                  //output_low(PIN_B3); 
....................                  //output_B((input_b() & 0b00001111)); 
....................                   
....................                  break; 
1DA8:  BRA    1E48
....................             case RIGHT : 
....................                  //printf("Robot Gira a la Derecha \r"); 
....................                  //verificar_level_ir(); 
....................                  control_tipo=0; 
1DAA:  BCF    xD2.6
....................                  output_B((input_b() & 0b00001111) | 0b01010000 ); //(M2B, M2A, M1B, M1A, PWM2, RB2, RB1, IRDATA)                  
1DAC:  MOVF   F81,W
1DAE:  ANDLW  0F
1DB0:  IORLW  50
1DB2:  MOVWF  F8A
....................                  vel_pwm = vel3; 
1DB4:  CLRF   4F
1DB6:  MOVLW  14
1DB8:  MOVWF  4E
....................                  output_high(PIN_B1); 
1DBA:  BSF    F8A.1
....................                  ejecucion_pwm(); 
1DBC:  RCALL  1800
....................                  output_low(PIN_B1); 
1DBE:  BCF    F8A.1
....................                  //setup_timer_2(t2_div_by_1, 224, 1);  //PR2=224, Tpwm=225 us 
....................                  //set_pwm1_duty(vel_pwm); 
....................                  //set_pwm2_duty(vel_pwm); 
....................                  //setup_ccp1(ccp_pwm); 
....................                  //setup_ccp2(ccp_pwm); 
....................                  //delay_ms(400); 
....................                  //setup_ccp1(ccp_off); 
....................                  //setup_ccp2(ccp_off); 
....................                  //output_low(PIN_C2); 
....................                  //output_low(PIN_B3); 
....................                  //output_B((input_b() & 0b00001111)); 
....................                   
....................                  break; 
1DC0:  BRA    1E48
....................             case SOUND : 
....................                  printf("Emite un sonido \r"); 
1DC2:  MOVLW  4C
1DC4:  MOVWF  FF6
1DC6:  MOVLW  0E
1DC8:  MOVWF  FF7
1DCA:  CALL   0EA6
....................                  generate_tone(391, 187); 
1DCE:  MOVLW  01
1DD0:  MOVWF  xED
1DD2:  MOVLW  87
1DD4:  MOVWF  xEC
1DD6:  CLRF   xEF
1DD8:  MOVLW  BB
1DDA:  MOVWF  xEE
1DDC:  CALL   1068
....................                  generate_tone(523, 187); 
1DE0:  MOVLW  02
1DE2:  MOVWF  xED
1DE4:  MOVLW  0B
1DE6:  MOVWF  xEC
1DE8:  CLRF   xEF
1DEA:  MOVLW  BB
1DEC:  MOVWF  xEE
1DEE:  CALL   1068
....................                  generate_tone(659, 187); 
1DF2:  MOVLW  02
1DF4:  MOVWF  xED
1DF6:  MOVLW  93
1DF8:  MOVWF  xEC
1DFA:  CLRF   xEF
1DFC:  MOVLW  BB
1DFE:  MOVWF  xEE
1E00:  CALL   1068
....................                  generate_tone(783, 187); 
1E04:  MOVLW  03
1E06:  MOVWF  xED
1E08:  MOVLW  0F
1E0A:  MOVWF  xEC
1E0C:  CLRF   xEF
1E0E:  MOVLW  BB
1E10:  MOVWF  xEE
1E12:  CALL   1068
....................                  delay_ms(187); 
1E16:  MOVLW  BB
1E18:  MOVLB  1
1E1A:  MOVWF  x03
1E1C:  MOVLB  0
1E1E:  CALL   0E5E
....................                  generate_tone(659, 187); 
1E22:  MOVLW  02
1E24:  MOVWF  xED
1E26:  MOVLW  93
1E28:  MOVWF  xEC
1E2A:  CLRF   xEF
1E2C:  MOVLW  BB
1E2E:  MOVWF  xEE
1E30:  CALL   1068
....................                  generate_tone(783, 1125);    
1E34:  MOVLW  03
1E36:  MOVWF  xED
1E38:  MOVLW  0F
1E3A:  MOVWF  xEC
1E3C:  MOVLW  04
1E3E:  MOVWF  xEF
1E40:  MOVLW  65
1E42:  MOVWF  xEE
1E44:  CALL   1068
....................                  break;         
....................             } 
....................        } 
1E48:  BRA    20AA
....................        else{ 
....................               
....................        bit_clear(bytes[0],4); 
1E4A:  BCF    xE6.4
....................      
....................        switch (bytes[0]){ 
1E4C:  MOVF   xE6,W
1E4E:  XORLW  05
1E50:  BZ    1E5A
1E52:  XORLW  0C
1E54:  BTFSC  FD8.2
1E56:  BRA    1FA6
1E58:  BRA    200E
....................             case GO : 
....................                   //printf("!RSET\r"); 
....................                  for(i=0;i<contador;++i){ 
1E5A:  CLRF   xD3
1E5C:  MOVF   xDD,W
1E5E:  SUBWF  xD3,W
1E60:  BTFSC  FD8.0
1E62:  BRA    1F6A
....................                       
....................                      switch (datos[i]){ 
1E64:  CLRF   03
1E66:  MOVF   xD3,W
1E68:  ADDLW  1C
1E6A:  MOVWF  FE9
1E6C:  MOVLW  00
1E6E:  ADDWFC 03,W
1E70:  MOVWF  FEA
1E72:  MOVF   FEF,W
1E74:  XORLW  02
1E76:  BZ    1E8A
1E78:  XORLW  0A
1E7A:  BZ    1EA0
1E7C:  XORLW  0C
1E7E:  BZ    1EB6
1E80:  XORLW  02
1E82:  BZ    1ECA
1E84:  XORLW  05
1E86:  BZ    1EE0
1E88:  BRA    1F5C
....................                      case UP: 
....................                           mov_act = UP; 
1E8A:  MOVLW  02
1E8C:  MOVWF  1B
....................                           control_tipo=1; 
1E8E:  BSF    xD2.6
....................                           output_B((input_b() & 0b00001111) | 0b01100000 );  
1E90:  MOVF   F81,W
1E92:  ANDLW  0F
1E94:  IORLW  60
1E96:  MOVWF  F8A
....................                           output_high(PIN_B1); 
1E98:  BSF    F8A.1
....................                           ejecucion_pwm(); 
1E9A:  RCALL  1800
....................                           output_low(PIN_B1); 
1E9C:  BCF    F8A.1
....................                           break; 
1E9E:  BRA    1F66
....................                      case DOWN: 
....................                           mov_act = DOWN; 
1EA0:  MOVLW  08
1EA2:  MOVWF  1B
....................                           control_tipo=1; 
1EA4:  BSF    xD2.6
....................                           output_B((input_b() & 0b00001111) | 0b10010000 ); 
1EA6:  MOVF   F81,W
1EA8:  ANDLW  0F
1EAA:  IORLW  90
1EAC:  MOVWF  F8A
....................                           output_high(PIN_B1); 
1EAE:  BSF    F8A.1
....................                           ejecucion_pwm(); 
1EB0:  RCALL  1800
....................                           output_low(PIN_B1); 
1EB2:  BCF    F8A.1
....................                           break; 
1EB4:  BRA    1F66
....................                      case LEFT: 
....................                           mov_act = LEFT; 
1EB6:  MOVLW  04
1EB8:  MOVWF  1B
....................                           control_tipo=1; 
1EBA:  BSF    xD2.6
....................                           output_B((input_b() & 0b00001111) | 0b01010000 ); 
1EBC:  MOVF   F81,W
1EBE:  ANDLW  0F
1EC0:  IORLW  50
1EC2:  MOVWF  F8A
....................                           output_high(PIN_B1); 
1EC4:  BSF    F8A.1
....................                           ejecucion_pwm(); 
1EC6:  RCALL  1800
....................                           break; 
1EC8:  BRA    1F66
....................                      case RIGHT: 
....................                           mov_act = RIGHT; 
1ECA:  MOVLW  06
1ECC:  MOVWF  1B
....................                           control_tipo=1; 
1ECE:  BSF    xD2.6
....................                           output_B((input_b() & 0b00001111) | 0b10100000 ); 
1ED0:  MOVF   F81,W
1ED2:  ANDLW  0F
1ED4:  IORLW  A0
1ED6:  MOVWF  F8A
....................                           output_high(PIN_B1); 
1ED8:  BSF    F8A.1
....................                           ejecucion_pwm(); 
1EDA:  RCALL  1800
....................                           output_low(PIN_B1); 
1EDC:  BCF    F8A.1
....................                           break; 
1EDE:  BRA    1F66
....................                      case SOUND:  
....................                           generate_tone(391, 187); 
1EE0:  MOVLW  01
1EE2:  MOVWF  xED
1EE4:  MOVLW  87
1EE6:  MOVWF  xEC
1EE8:  CLRF   xEF
1EEA:  MOVLW  BB
1EEC:  MOVWF  xEE
1EEE:  CALL   1068
....................                           generate_tone(523, 187); 
1EF2:  MOVLW  02
1EF4:  MOVWF  xED
1EF6:  MOVLW  0B
1EF8:  MOVWF  xEC
1EFA:  CLRF   xEF
1EFC:  MOVLW  BB
1EFE:  MOVWF  xEE
1F00:  CALL   1068
....................                           generate_tone(659, 187); 
1F04:  MOVLW  02
1F06:  MOVWF  xED
1F08:  MOVLW  93
1F0A:  MOVWF  xEC
1F0C:  CLRF   xEF
1F0E:  MOVLW  BB
1F10:  MOVWF  xEE
1F12:  CALL   1068
....................                           generate_tone(783, 187); 
1F16:  MOVLW  03
1F18:  MOVWF  xED
1F1A:  MOVLW  0F
1F1C:  MOVWF  xEC
1F1E:  CLRF   xEF
1F20:  MOVLW  BB
1F22:  MOVWF  xEE
1F24:  CALL   1068
....................                           delay_ms(187); 
1F28:  MOVLW  BB
1F2A:  MOVLB  1
1F2C:  MOVWF  x03
1F2E:  MOVLB  0
1F30:  CALL   0E5E
....................                           generate_tone(659, 187); 
1F34:  MOVLW  02
1F36:  MOVWF  xED
1F38:  MOVLW  93
1F3A:  MOVWF  xEC
1F3C:  CLRF   xEF
1F3E:  MOVLW  BB
1F40:  MOVWF  xEE
1F42:  CALL   1068
....................                           generate_tone(783, 1125); 
1F46:  MOVLW  03
1F48:  MOVWF  xED
1F4A:  MOVLW  0F
1F4C:  MOVWF  xEC
1F4E:  MOVLW  04
1F50:  MOVWF  xEF
1F52:  MOVLW  65
1F54:  MOVWF  xEE
1F56:  CALL   1068
....................                           break;   
1F5A:  BRA    1F66
....................                      default : 
....................                      delay_us(100); 
1F5C:  MOVLW  A6
1F5E:  MOVWF  00
1F60:  DECFSZ 00,F
1F62:  BRA    1F60
1F64:  NOP   
....................                      break; 
....................                      } 
1F66:  INCF   xD3,F
1F68:  BRA    1E5C
....................                       
....................                       
....................                                           
....................                  } 
....................                      generate_tone(659, 152); 
1F6A:  MOVLW  02
1F6C:  MOVWF  xED
1F6E:  MOVLW  93
1F70:  MOVWF  xEC
1F72:  CLRF   xEF
1F74:  MOVLW  98
1F76:  MOVWF  xEE
1F78:  CALL   1068
....................                      delay_ms(35); 
1F7C:  MOVLW  23
1F7E:  MOVLB  1
1F80:  MOVWF  x03
1F82:  MOVLB  0
1F84:  CALL   0E5E
....................                      generate_tone(659, 562); 
1F88:  MOVLW  02
1F8A:  MOVWF  xED
1F8C:  MOVLW  93
1F8E:  MOVWF  xEC
1F90:  MOVLW  02
1F92:  MOVWF  xEF
1F94:  MOVLW  32
1F96:  MOVWF  xEE
1F98:  CALL   1068
....................                      distancia_recorrida_1=0; 
1F9C:  CLRF   45
1F9E:  CLRF   44
....................                      distancia_recorrida_2=0; 
1FA0:  CLRF   47
1FA2:  CLRF   46
....................                         
....................                  break; 
1FA4:  BRA    20AA
....................             case RESET : 
....................                         for(i=0;i<total_datos;++i){ 
1FA6:  CLRF   xD3
1FA8:  MOVF   xD3,W
1FAA:  SUBLW  18
1FAC:  BNC   1FC2
....................                             datos[i]='\0'; 
1FAE:  CLRF   03
1FB0:  MOVF   xD3,W
1FB2:  ADDLW  1C
1FB4:  MOVWF  FE9
1FB6:  MOVLW  00
1FB8:  ADDWFC 03,W
1FBA:  MOVWF  FEA
1FBC:  CLRF   FEF
1FBE:  INCF   xD3,F
1FC0:  BRA    1FA8
....................                             } 
....................                             contador=0; 
1FC2:  CLRF   xDD
....................                         generate_tone(1000, 180); 
1FC4:  MOVLW  03
1FC6:  MOVWF  xED
1FC8:  MOVLW  E8
1FCA:  MOVWF  xEC
1FCC:  CLRF   xEF
1FCE:  MOVLW  B4
1FD0:  MOVWF  xEE
1FD2:  CALL   1068
....................                         generate_tone(600, 240); 
1FD6:  MOVLW  02
1FD8:  MOVWF  xED
1FDA:  MOVLW  58
1FDC:  MOVWF  xEC
1FDE:  CLRF   xEF
1FE0:  MOVLW  F0
1FE2:  MOVWF  xEE
1FE4:  CALL   1068
....................                         generate_tone(280, 136); 
1FE8:  MOVLW  01
1FEA:  MOVWF  xED
1FEC:  MOVLW  18
1FEE:  MOVWF  xEC
1FF0:  CLRF   xEF
1FF2:  MOVLW  88
1FF4:  MOVWF  xEE
1FF6:  CALL   1068
....................                         generate_tone(1500, 200); 
1FFA:  MOVLW  05
1FFC:  MOVWF  xED
1FFE:  MOVLW  DC
2000:  MOVWF  xEC
2002:  CLRF   xEF
2004:  MOVLW  C8
2006:  MOVWF  xEE
2008:  CALL   1068
....................           
....................                  break;         
200C:  BRA    20AA
....................             default : 
....................                   datos[contador]=bytes[0]; 
200E:  CLRF   03
2010:  MOVF   xDD,W
2012:  ADDLW  1C
2014:  MOVWF  FE9
2016:  MOVLW  00
2018:  ADDWFC 03,W
201A:  MOVWF  FEA
201C:  MOVFF  E6,FEF
....................                    
....................                   switch (datos[contador]){ 
2020:  CLRF   03
2022:  MOVF   xDD,W
2024:  ADDLW  1C
2026:  MOVWF  FE9
2028:  MOVLW  00
202A:  ADDWFC 03,W
202C:  MOVWF  FEA
202E:  MOVLW  02
2030:  SUBWF  FEF,W
2032:  ADDLW  F9
2034:  BC    20A8
2036:  ADDLW  07
2038:  GOTO   20EA
....................                      case UP: 
....................                           generate_tone(C_NOTE[0], 500);                           
203C:  MOVLW  01
203E:  MOVWF  xED
2040:  MOVLW  06
2042:  MOVWF  xEC
2044:  MOVLW  01
2046:  MOVWF  xEF
2048:  MOVLW  F4
204A:  MOVWF  xEE
204C:  CALL   1068
....................                           break; 
2050:  BRA    20A8
....................                      case DOWN: 
....................                           generate_tone(E_NOTE[0], 500); 
2052:  MOVLW  01
2054:  MOVWF  xED
2056:  MOVLW  4A
2058:  MOVWF  xEC
205A:  MOVLW  01
205C:  MOVWF  xEF
205E:  MOVLW  F4
2060:  MOVWF  xEE
2062:  CALL   1068
....................                           break; 
2066:  BRA    20A8
....................                      case LEFT: 
....................                           generate_tone(A_NOTE[0], 500); 
2068:  MOVLW  01
206A:  MOVWF  xED
206C:  MOVLW  B8
206E:  MOVWF  xEC
2070:  MOVLW  01
2072:  MOVWF  xEF
2074:  MOVLW  F4
2076:  MOVWF  xEE
2078:  CALL   1068
....................                           break; 
207C:  BRA    20A8
....................                      case RIGHT: 
....................                           generate_tone(C_NOTE[1], 500); 
207E:  MOVLW  02
2080:  MOVWF  xED
2082:  MOVLW  0B
2084:  MOVWF  xEC
2086:  MOVLW  01
2088:  MOVWF  xEF
208A:  MOVLW  F4
208C:  MOVWF  xEE
208E:  CALL   1068
....................                           break; 
2092:  BRA    20A8
....................                      case SOUND: 
....................                           generate_tone(E_NOTE[1], 500);  
2094:  MOVLW  02
2096:  MOVWF  xED
2098:  MOVLW  93
209A:  MOVWF  xEC
209C:  MOVLW  01
209E:  MOVWF  xEF
20A0:  MOVLW  F4
20A2:  MOVWF  xEE
20A4:  CALL   1068
....................                            
....................                           break;              
....................                      } 
....................                   contador++; 
20A8:  INCF   xDD,F
....................                    
....................                    
....................                    
....................                  break; 
20AA:  CLRF   19
20AC:  BTFSC  FF2.7
20AE:  BSF    19.7
20B0:  BCF    FF2.7
....................             }        
....................        } 
....................        } 
....................        limpia_bits(); 
20B2:  CALL   0CBC
20B6:  BTFSC  19.7
20B8:  BSF    FF2.7
....................        enable_interrupts(global); 
20BA:  MOVLW  C0
20BC:  IORWF  FF2,F
....................         
....................      
....................     } 
....................      
....................   }  
....................   while (TRUE); 
20BE:  BRA    1C80
....................    
.................... } 
20C0:  SLEEP 

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 0E18   PUT NOBROWNOUT BORV21 NOWDT WDT128
   Word  3: 0000   CCP2B3 NOPBADEN NOLPT1OSC NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
